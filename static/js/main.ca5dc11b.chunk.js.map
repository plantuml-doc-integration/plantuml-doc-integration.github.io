{"version":3,"sources":["element/dialog/DialogBase.js","element/dialog/LargeIconDialogContent.js","util/Store.js","util/AuthorizeRedirector.js","page/auth/AuthorizeDialog.js","element/dialog/InputDialogContent.js","page/docs/OpenDocumentDialog.js","element/HeaderBar.js","element/plantuml/PlantImage.js","element/plantuml/PlantExpansionPanel.js","plantuml/js-deflate/rawdeflate.js","plantuml/PlantUMLEncoder.js","data/DiagramParser.js","page/docs/DocsPage.js","page/HomePage.js","page/auth/AuthPage.js","element/Footer.js","PlantDocApp.js","serviceWorker.js","index.js"],"names":["CommonDialog","prevProps","open","this","props","onReset","Dialog","DialogTitle","title","children","React","Component","LargeIconDialogContent","iconClass","icon","caption","DialogContent","className","clsx","Typography","variant","DialogContentText","create","storage","name","store","obj","setItem","JSON","stringify","load","string","getItem","parse","clear","removeItem","exists","tokenStore","localStorage","redirectDocIdStore","redirectToAuthUrl","a","success","axios","get","response","status","window","location","href","data","authUrl","console","log","AuthorizeDialog","state","loading","fail","authorized","unauthorize","onClose","authorize","setState","reset","condition","ErrorOutlineOutlined","DialogActions","Button","color","onClick","CircularProgress","size","VpnKeyOutlined","LockOutlined","InputDialogContent","label","value","onChange","error","TextField","margin","autoFocus","e","target","helperText","required","fullWidth","OpenDocumentDialog","input","proceed","validateInput","processInput","prefix","startsWith","slash","substring","length","indexOf","v","onChangeInput","onClickClose","HeaderBar","openAuthorizeDialog","openOpenDocumentDialog","openDocument","history","push","AppBar","position","Toolbar","Tooltip","IconButton","edge","InsertDriveFileOutlined","AccountCircleOutlined","document","setOpenDocument","withRouter","PlantImage","src","alt","width","PlantPaper","valid","id","Accordion","AccordionSummary","expandIcon","ExpandMore","aria-controls","AccordionDetails","deflate","zip_free_queue","zip_qhead","zip_qtail","zip_initflag","zip_outcnt","zip_outoff","zip_complete","zip_window","zip_d_buf","zip_l_buf","zip_prev","zip_bi_buf","zip_bi_valid","zip_block_start","zip_ins_h","zip_hash_head","zip_prev_match","zip_match_available","zip_match_length","zip_prev_length","zip_strstart","zip_match_start","zip_eofile","zip_lookahead","zip_max_chain_length","zip_max_lazy_match","zip_compr_level","zip_good_match","zip_dyn_ltree","zip_dyn_dtree","zip_static_ltree","zip_static_dtree","zip_bl_tree","zip_l_desc","zip_d_desc","zip_bl_desc","zip_bl_count","zip_heap","zip_heap_len","zip_heap_max","zip_depth","zip_length_code","zip_dist_code","zip_base_length","zip_base_dist","zip_flag_buf","zip_last_lit","zip_last_dist","zip_last_flags","zip_flags","zip_flag_bit","zip_opt_len","zip_static_len","zip_deflate_data","zip_deflate_pos","zip_H_SHIFT","parseInt","zip_outbuf","zip_DeflateCT","fc","dl","zip_DeflateTreeDesc","dyn_tree","static_tree","extra_bits","extra_base","elems","max_length","max_code","zip_DeflateConfiguration","b","c","d","good_length","max_lazy","nice_length","max_chain","zip_DeflateBuffer","next","len","ptr","Array","off","zip_extra_lbits","zip_extra_dbits","zip_extra_blbits","zip_bl_order","zip_configuration_table","zip_reuse_queue","p","zip_head1","i","zip_head2","val","zip_put_byte","q","zip_new_queue","zip_qoutbuf","zip_put_short","w","zip_OUTBUFSIZ","zip_INSERT_STRING","zip_HASH_SIZE","zip_WSIZE","zip_SEND_CODE","tree","zip_send_bits","zip_D_CODE","dist","zip_SMALLER","n","m","zip_read_buff","buff","offset","charCodeAt","zip_longest_match","cur_match","matchp","chain_length","scanp","best_len","limit","strendp","scan_end1","scan_end","zip_fill_window","more","zip_init_deflate","bits","code","zip_LITERALS","zip_LENGTH_CODES","zip_gen_codes","zip_L_CODES","zip_bi_reverse","zip_init_block","zip_ct_init","j","zip_MAX_MATCH","zip_MIN_MATCH","zip_lm_init","zip_deflate_internal","buff_size","zip_qcopy","flush","zip_ct_tally","zip_flush_block","zip_deflate_fast","zip_deflate_better","zip_pqdownheap","k","next_code","zip_MAX_BITS","zip_build_tree","desc","stree","node","xnew","h","xbits","f","extra","base","overflow","zip_gen_bitlen","zip_scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","zip_send_tree","eof","opt_lenb","static_lenb","max_blindex","stored_len","zip_BL_CODES","zip_build_bl_tree","zip_bi_windup","zip_compress_block","lcodes","dcodes","blcodes","rank","zip_send_all_trees","lc","dcode","out_length","in_length","zip_LIT_BUFSIZE","ltree","dtree","lx","dx","fx","flag","res","str","level","zip_INBUFSIZ","zip_deflate_start","aout","cbuf","String","fromCharCode","join","append3bytes","b1","b2","b3","c2","c3","c4","r","encode6bit","convertPlantUMLSourceToImageURL","pumlString","unescapedUMLString","unescape","encodeURIComponent","encode64","defaultConfig","addTitle","parseDiagramData","rawData","config","index","dataString","umlString","dataArray","split","dataObject","forEach","trim","spaceIndex","imageUrl","DocPage","undefined","loadDocument","match","params","docId","headers","authorization","documentId","diagrams","map","updateDocument","filter","diagram","key","HomePage","AuthorizeFinishDialog","retry","verifyCode","token","retryAuthorize","redirectHome","redirectDocs","queryString","search","DoneOutlineOutlined","Footer","PlantDocApp","path","component","DocsPage","AuthPage","exact","Boolean","hostname","isLocalhost","defaults","baseURL","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"6TAIqBA,E,iLAODC,GACdA,EAAUC,OAASC,KAAKC,MAAMF,MAAQC,KAAKC,MAAMF,MACpDC,KAAKC,MAAMC,SAAWF,KAAKC,MAAMC,Y,+BAIlC,OACC,6BACC,kBAACC,EAAA,EAAD,eAAQJ,KAAMC,KAAKC,MAAMF,MAAUC,KAAKC,OACvC,kBAACG,EAAA,EAAD,KAAcJ,KAAKC,MAAMI,OACxBL,KAAKC,MAAMK,e,GAjByBC,IAAMC,W,qECAjC,SAASC,EAAT,GAAyE,IAAvCC,EAAsC,EAAtCA,UAAWC,EAA2B,EAA3BA,KAAMC,EAAqB,EAArBA,QAASN,EAAY,EAAZA,SAC1E,OACC,kBAACO,EAAA,EAAD,KACC,yBAAKC,UAAWC,YAAK,eAAgBL,IACnCC,EACD,kBAACK,EAAA,EAAD,CAAYC,QAAQ,MAAML,IAE3B,kBAACM,EAAA,EAAD,KACEZ,ICZL,IAGMa,EAAS,SAACC,EAASC,GAkBxB,MAAO,CAAEC,MAjBK,SAACC,GACdH,EAAQI,QAAQH,EAAMI,KAAKC,UAAUH,KAgBtBI,KAbH,WACZ,IAAMC,EAASR,EAAQS,QAAQR,GAC/B,OAAe,OAAXO,EAAwB,KACrBH,KAAKK,MAAMF,IAUGG,MAPR,WACbX,EAAQY,WAAWX,IAMSY,OAHd,WACd,OAAiC,OAA1Bb,EAAQS,QAAQR,MAIZa,EAAaf,EAAOgB,aAvBd,qCAwBNC,EAAqBjB,EAAOgB,aAvBb,2CCAb,SAAeE,IAA9B,+B,4CAAe,8BAAAC,EAAA,6DACVC,GAAU,EADA,kBAGUC,IAAMC,IAAN,aAHV,OAIW,OADlBC,EAHO,QAIAC,OACZC,OAAOC,SAASC,KAAOJ,EAASK,KAAKC,QAErCT,GAAU,EAPE,gDAUbU,QAAQC,IAAR,MACAX,GAAU,EAXG,iCAaPA,GAbO,0D,0BCUMY,E,4MAKpBC,MAAQ,CACPC,SAAS,EACTC,MAAM,EACNC,YAAY,G,EAWbC,YAAc,WACbtB,EAAWH,QACXK,EAAmBL,QACnB,EAAK9B,MAAMwD,W,EAGZC,U,sBAAY,sBAAApB,EAAA,sDACX,EAAKqB,SAAS,CACbN,SAAS,EACTC,MAAM,GAFP,sBAGG,sBAAAhB,EAAA,sEACoBD,IADpB,eAGD,EAAKsB,SAAS,CAAEN,SAAS,EAAMC,MAAM,IAHpC,4CAJQ,2C,sDAbXtD,KAAK2D,SAAS,CACbN,SAAS,EACTC,MAAM,EACNC,WAAYrB,EAAWD,a,+BAsBf,IAAD,OACR,OACC,kBAAC,EAAD,CAAYlC,KAAMC,KAAKC,MAAMF,KAAM0D,QAAS,kBAAM,EAAKxD,MAAMwD,WAAWvD,QAAS,kBAAM,EAAK0D,SAASvD,MAAM,iBAC1G,kBAAC,KAAD,CAAIwD,UAAW7D,KAAKoD,MAAMC,SACzB,kBAAC,OAAD,KACC,kBAAC,KAAD,CAAIQ,UAAW7D,KAAKoD,MAAME,MACzB,kBAAC,OAAD,KACC,kBAAC7C,EAAD,CAAwBC,UAAU,eAAeC,KAAM,kBAACmD,EAAA,EAAD,CAAsBhD,UAAU,eAAiBF,QAAQ,qBAAhH,mDAGA,kBAACmD,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAQC,MAAM,UAAUC,QAAS,kBAAM,EAAKjE,MAAMwD,YAAlD,UACA,kBAACO,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKR,cAAhE,WAGF,kBAAC,OAAD,KACC,kBAACjD,EAAD,CAAwBE,KAAM,kBAACwD,EAAA,EAAD,CAAkBC,KAAK,SAAWxD,QAAQ,kBAAxE,uCAMH,kBAAC,OAAD,KACC,kBAAC,KAAD,CAAIiD,UAAW7D,KAAKoD,MAAMG,YACzB,kBAAC,OAAD,KACC,kBAAC9C,EAAD,CAAwBC,UAAU,aAAaC,KAAM,kBAAC0D,EAAA,EAAD,CAAgBvD,UAAU,eAAiBF,QAAQ,cAAxG,oJAE8D,0CAF9D,UAEuF,6BAAM,6BAF7F,6HAMD,kBAAC,OAAD,KACC,kBAACH,EAAD,CAAwBC,UAAU,eAAeC,KAAM,kBAAC2D,EAAA,EAAD,CAAcxD,UAAU,eAAiBF,QAAQ,gBAAxG,mLAEwE,6BAAM,6BAF9E,8HAG4H,wCAH5H,oBAOF,kBAACmD,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAQC,MAAM,UAAUC,QAAS,kBAAM,EAAKjE,MAAMwD,YAAlD,UACA,kBAAC,KAAD,CAAII,UAAW7D,KAAKoD,MAAMG,YACzB,kBAAC,OAAD,KACC,kBAACS,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKV,gBAAhE,gBAED,kBAAC,OAAD,KACC,kBAACQ,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKR,cAAhE,wB,GAnFoCnD,IAAMC,W,+DCPpC,SAAS+D,EAAT,GAA0E,IAA5CjE,EAA2C,EAA3CA,SAAUkE,EAAiC,EAAjCA,MAAOC,EAA0B,EAA1BA,MAAOC,EAAmB,EAAnBA,SAAUC,EAAS,EAATA,MAC9E,OACC,kBAAC9D,EAAA,EAAD,KACC,kBAACK,EAAA,EAAD,KAAoBZ,GACpB,kBAACsE,EAAA,EAAD,CACCC,OAAO,SACPC,WAAS,EACTN,MAAOA,EACPC,MAAOA,EACPC,SAAU,SAACK,GAAD,OAAOL,EAASK,EAAEC,OAAOP,QACnCE,QAASA,EACTM,WAAYN,GAAgB,IAC5BO,UAAQ,EACRC,WAAS,K,ICZQC,E,4MAKpBhC,MAAQ,CACPiC,MAAO,GACPV,MAAO,I,sDAGP3E,KAAK2D,SAAS,CAAE0B,MAAO,GAAIV,MAAO,O,oCAErBU,GACbrF,KAAK2D,SAAS,CAAE0B,QAAOV,MAAO,O,mCAElBW,GACPA,EAGAtF,KAAKuF,cAAcvF,KAAKoD,MAAMiC,QACjCrF,KAAKC,MAAMwD,QAAQzD,KAAKwF,aAAaxF,KAAKoD,MAAMiC,QAHjDrF,KAAKC,MAAMwD,SAAQ,K,oCAOP4B,GACb,QAAKA,IACJrF,KAAK2D,SAAS,CAAEgB,MAAO,sBAChB,K,mCAIIU,GACZ,IAAMI,EAAS,sCACf,GAAIJ,EAAMK,WAAWD,GAAS,CAE7B,IAAME,GADNN,EAAQA,EAAMO,UAAUH,EAAOI,SACXC,QAAQ,KACxBH,EAAQ,IACXN,EAAQA,EAAMO,UAAU,EAAGD,IAG7B,OAAON,I,+BAEE,IAAD,OACR,OACC,kBAAC,EAAD,CAAYF,WAAS,EAACpF,KAAMC,KAAKC,MAAMF,KAAMM,MAAM,wBAAwBH,QAAS,kBAAM,EAAK0D,UAC9F,kBAACW,EAAD,CAAoBC,MAAM,mBAAmBC,MAAOzE,KAAKoD,MAAMiC,MAAOX,SAAU,SAACqB,GAAD,OAAO,EAAKC,cAAcD,IAAIpB,MAAO3E,KAAKoD,MAAMuB,OAAhI,wCAGA,kBAACZ,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAQC,MAAM,UAAUC,QAAS,kBAAM,EAAK+B,cAAa,KAAzD,UACA,kBAACjC,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAK+B,cAAa,KAA7E,c,GAlD2C1F,IAAMC,WCEhD0F,E,4MAIL9C,MAAQ,CACP+C,qBAAqB,EACrBC,wBAAwB,G,8DAETC,GACfpD,QAAQC,IAAImD,GACZrG,KAAK2D,SAAS,CAAEyC,wBAAwB,IACpCC,GACHrG,KAAKC,MAAMqG,QAAQC,KAAnB,gBAAiCF,M,+BAGzB,IAAD,OACR,OACC,gCACC,kBAACG,EAAA,EAAD,CAAQC,SAAS,UAChB,kBAACC,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAStG,MAAM,iBACd,kBAACuG,EAAA,EAAD,CAAYC,KAAK,QAAQ5C,MAAM,UAAUC,QAAS,kBAAM,EAAKP,SAAS,CAAEyC,wBAAwB,MAC/F,kBAACU,EAAA,EAAD,CAAyBhG,UAAU,kBAIrC,kBAACE,EAAA,EAAD,CAAYC,QAAQ,MAClBjB,KAAKC,MAAMI,OAEb,yBAAKS,UAAU,uBACd,kBAAC6F,EAAA,EAAD,CAAStG,MAAM,iBACd,kBAACuG,EAAA,EAAD,CAAYC,KAAK,QAAQ5C,MAAM,UAAUC,QAAS,kBAAM,EAAKP,SAAS,CAAEwC,qBAAqB,MAC5F,kBAACY,EAAA,EAAD,CAAuBjG,UAAU,qBAYtC,kBAAC,EAAD,CAAoBf,KAAMC,KAAKoD,MAAMgD,uBAAwB3C,QAAS,SAACuD,GAAD,OAAc,EAAKC,gBAAgBD,MAEzG,kBAAC,EAAD,CAAiBjH,KAAMC,KAAKoD,MAAM+C,oBAAqB1C,QAAS,kBAAM,EAAKE,SAAS,CAAEwC,qBAAqB,Y,GA9CvF5F,IAAMC,WAoDf0G,cAAWhB,G,oCCzDX,SAASiB,EAAT,GAAqC,IAAfC,EAAc,EAAdA,IAAK/G,EAAS,EAATA,MACxC,OACE,6BACE,yBAAKgH,IAAKhH,GAAgB,oBAAqB+G,IAAKA,EAAKE,MAAM,SADjE,KCEW,SAASC,GAAT,GAA+C,IAAzBC,EAAwB,EAAxBA,MAAOzE,EAAiB,EAAjBA,KAAMqE,EAAW,EAAXA,IAAKK,EAAM,EAANA,GACtD,OACC,kBAACC,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAkBC,WAAY,kBAACC,EAAA,EAAD,MAC7BC,gBAAA,iBAAyBL,EAAzB,YACAA,GAAE,iBAAYA,EAAZ,YACF,kBAAC,KAAD,CAAI5D,UAAW2D,GACd,kBAAC,OAAD,KACC,kBAACxG,EAAA,EAAD,CAAYC,QAAQ,MAAM8B,EAAK1C,MAAQ0C,EAAK1C,MAAQ,aAErD,kBAAC,OAAD,KACC,kBAACW,EAAA,EAAD,CAAYC,QAAQ,MAApB,sBAIH,kBAAC,OAAD,CAAM4C,UAAW2D,GAChB,kBAACO,EAAA,EAAD,KACC,kBAACZ,EAAD,CAAYC,IAAKA,EAAK/G,MAAO0C,EAAK1C,WCTvC,IAynDe2H,GAznDA,WAYd,IAyDIC,EACAC,EAAWC,EACXC,EAEAC,EAAYC,EACZC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GA1DAC,GAAcC,SAAS,GAOvBC,GAAa,KAuDjB,SAASC,KACR3L,KAAK4L,GAAK,EACV5L,KAAK6L,GAAK,EAGX,SAASC,KACR9L,KAAK+L,SAAW,KAChB/L,KAAKgM,YAAc,KACnBhM,KAAKiM,WAAa,KAClBjM,KAAKkM,WAAa,EAClBlM,KAAKmM,MAAQ,EACbnM,KAAKoM,WAAa,EAClBpM,KAAKqM,SAAW,EAQjB,SAASC,GAAyBhK,EAAGiK,EAAGC,EAAGC,GAC1CzM,KAAK0M,YAAcpK,EACnBtC,KAAK2M,SAAWJ,EAChBvM,KAAK4M,YAAcJ,EACnBxM,KAAK6M,UAAYJ,EAGlB,SAASK,KACR9M,KAAK+M,KAAO,KACZ/M,KAAKgN,IAAM,EACXhN,KAAKiN,IAAM,IAAIC,MAvII,MAwInBlN,KAAKmN,IAAM,EAIZ,IAAIC,GAAkB,CACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACjFC,GAAkB,CACrB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC3FC,GAAmB,CACtB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnDC,GAAe,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IAC9EC,GAA0B,CAC7B,IAAIlB,GAAyB,EAAG,EAAG,EAAG,GACtC,IAAIA,GAAyB,EAAG,EAAG,EAAG,GACtC,IAAIA,GAAyB,EAAG,EAAG,GAAI,GACvC,IAAIA,GAAyB,EAAG,EAAG,GAAI,IACvC,IAAIA,GAAyB,EAAG,EAAG,GAAI,IACvC,IAAIA,GAAyB,EAAG,GAAI,GAAI,IACxC,IAAIA,GAAyB,EAAG,GAAI,IAAK,KACzC,IAAIA,GAAyB,EAAG,GAAI,IAAK,KACzC,IAAIA,GAAyB,GAAI,IAAK,IAAK,MAC3C,IAAIA,GAAyB,GAAI,IAAK,IAAK,OAgF5C,SAASmB,GAAgBC,GACxBA,EAAEX,KAAO9E,EACTA,EAAiByF,EAkBlB,SAASC,GAAUC,GAClB,OAAOjF,EA5QQ,MA4QaiF,GAG7B,SAASC,GAAUD,EAAGE,GACrB,OAAOnF,EAhRQ,MAgRaiF,GAAKE,EAQlC,SAASC,GAAavB,GACrBd,GAAWpD,EAAaD,KAAgBmE,EACpClE,EAAaD,GAhRE,MA0jDpB,WACC,GAAkB,GAAdA,EAAiB,CACpB,IAAI2F,EAAGJ,EAQP,IAPAI,EA30CF,WACC,IAAIN,EAWJ,OATsB,MAAlBzF,GACHyF,EAAIzF,EACJA,EAAiBA,EAAe8E,MAGhCW,EAAI,IAAIZ,GACTY,EAAEX,KAAO,KACTW,EAAEV,IAAMU,EAAEP,IAAM,EAETO,EA+zCFO,GACa,MAAb/F,EACHA,EAAYC,EAAY6F,EAExB7F,EAAYA,EAAU4E,KAAOiB,EAC9BA,EAAEhB,IAAM3E,EAAaC,EAEhBsF,EAAI,EAAGA,EAAII,EAAEhB,IAAKY,IACtBI,EAAEf,IAAIW,GAAKlC,GAAWpD,EAAasF,GACpCvF,EAAaC,EAAa,GArzC1B4F,GAIF,SAASC,GAAcC,GACtBA,GAAK,MACD9F,EAAaD,EAAagG,MAC7B3C,GAAWpD,EAAaD,KAAqB,IAAJ+F,EACzC1C,GAAWpD,EAAaD,KAAiB+F,IAAM,IAE/CL,GAAiB,IAAJK,GACbL,GAAaK,IAAM,IAYrB,SAASE,KACRvF,EAjRmBwF,MAiRLxF,GAAayC,GACwB,IAA/ChD,EAAWa,EAxSI,EAwS2B,IAE9CL,EAAgB2E,GAAU5E,GAC1BJ,EApRe6F,MAoRNnF,GAA4BL,EACrC6E,GAAU9E,EAAWM,GAItB,SAASoF,GAAcjC,EAAGkC,GACzBC,GAAcD,EAAKlC,GAAGZ,GAAI8C,EAAKlC,GAAGX,IAOnC,SAAS+C,GAAWC,GACnB,OACuC,KAD/BA,EAAO,IAAMlE,EAAckE,GAChClE,EAAc,KAAOkE,GAAQ,KAOjC,SAASC,GAAYJ,EAAMK,EAAGC,GAC7B,OAAON,EAAKK,GAAGnD,GAAK8C,EAAKM,GAAGpD,IAC1B8C,EAAKK,GAAGnD,IAAM8C,EAAKM,GAAGpD,IAAMnB,EAAUsE,IAAMtE,EAAUuE,GAMzD,SAASC,GAAcC,EAAMC,EAAQJ,GACpC,IAAInB,EACJ,IAAKA,EAAI,EAAGA,EAAImB,GAAKxD,GAAkBD,EAAiBzF,OAAQ+H,IAC/DsB,EAAKC,EAASvB,GACoC,IAAjDtC,EAAiB8D,WAAW7D,MAC9B,OAAOqC,EAyDR,SAASyB,GAAkBC,GAC1B,IAEIC,EACAvC,EAHAwC,EAAe/F,EACfgG,EAAQpG,EAGRqG,EAAWtG,EAKXuG,EAAStG,EAtXKmF,MAsXyBnF,EAtXzBmF,MAHL,EA2XToB,EAAUvG,EAlZK,IAmZfwG,EAAYrH,EAAWiH,EAAQC,EAAW,GAC1CI,EAAWtH,EAAWiH,EAAQC,GAG9BtG,GAAmBQ,IACtB4F,IAAiB,GAIlB,GAOC,GAAIhH,GALJ+G,EAASD,GAKeI,IAAaI,GACpCtH,EAAW+G,EAASG,EAAW,IAAMG,GACrCrH,EAAW+G,IAAW/G,EAAWiH,IACjCjH,IAAa+G,IAAW/G,EAAWiH,EAAQ,GAH5C,CAaAA,GAAS,EACTF,IAKA,UACS/G,IAAaiH,IAAUjH,IAAa+G,IAC7C/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACpC/G,IAAaiH,IAAUjH,IAAa+G,IACnCE,EAAQG,GAKT,GAHA5C,EAjckB,KAicK4C,EAAUH,GACjCA,EAAQG,EAlcU,IAocd5C,EAAM0C,EAAU,CAIlB,GAHDpG,EAAkBgG,EAClBI,EAAW1C,EAENA,GAxcY,IAwcU,MAK3B6C,EAAYrH,EAAWiH,EAAQC,EAAW,GAC1CI,EAAWtH,EAAWiH,EAAQC,YAEtBJ,EAAY3G,EA1bP6F,MA0bgBc,IAA0BK,GACnC,KAAhBH,GAEN,OAAOE,EAWR,SAASK,KACR,IAAIhB,EAAGC,EAGHgB,EApeiB,MAoeQxG,EAAgBH,EAK7C,IAAa,GAAT2G,EAIHA,SACM,GAAI3G,GAAgBmF,MAA0B,CAOpD,IAAKO,EAAI,EAAGA,EAhgBE,MAggBaA,IAC1BvG,EAAWuG,GAAKvG,EAAWuG,EAjgBd,OAugBd,IAJAzF,GAngBc,MAogBdD,GApgBc,MAqgBdP,GArgBc,MAugBTiG,EAAI,EAAGA,EAteM,KAseaA,IAE9BlB,GAAUkB,GADVC,EAAIrB,GAAUoB,KAxgBD,MAygBiBC,EAzgBjB,MAoCF,GAueZ,IAAKD,EAAI,EAAGA,EA3gBE,MA2gBaA,IAI1BC,EAAIrG,EAASoG,GACbpG,EAASoG,GAAMC,GAhhBF,MAghBmBA,EAhhBnB,MAoCF,EA8eZgB,GAlhBc,MAqhBVzG,KACJwF,EAAIE,GAAczG,EAAYa,EAAeG,EAAewG,KACnD,EACRzG,GAAa,EAEbC,GAAiBuF,GAyLpB,SAASkB,KACJ1G,IAEJX,EAAa,EACbC,EAAe,EAsGhB,WACC,IAAIkG,EACAmB,EACArK,EACAsK,EACAtB,EAEJ,GAA8B,GAA1B7E,EAAiB,GAAG6B,GAAS,OA4BjC,IA1BA3B,EAAW6B,SAAWlC,EACtBK,EAAW8B,YAAcjC,EACzBG,EAAW+B,WAAamB,GACxBlD,EAAWgC,WAAakE,IACxBlG,EAAWiC,MA5xBMiE,IA6xBjBlG,EAAWkC,WAlyBO,GAmyBlBlC,EAAWmC,SAAW,EAEtBlC,EAAW4B,SAAWjC,EACtBK,EAAW6B,YAAchC,EACzBG,EAAW8B,WAAaoB,GACxBlD,EAAW+B,WAAa,EACxB/B,EAAWgC,MAnyBM,GAoyBjBhC,EAAWiC,WA1yBO,GA2yBlBjC,EAAWkC,SAAW,EAEtBjC,EAAY2B,SAAW9B,EACvBG,EAAY4B,YAAc,KAC1B5B,EAAY6B,WAAaqB,GACzBlD,EAAY8B,WAAa,EACzB9B,EAAY+B,MA1yBM,GA2yBlB/B,EAAYgC,WAjzBS,EAkzBrBhC,EAAYiC,SAAW,EAGvBxG,EAAS,EACJsK,EAAO,EAAGA,EAAOE,GAAsBF,IAE3C,IADAvF,EAAgBuF,GAAQtK,EACnBkJ,EAAI,EAAGA,EAAK,GAAK3B,GAAgB+C,GAAQpB,IAC7CrE,EAAgB7E,KAAYsK,EAY9B,IAJAzF,EAAgB7E,EAAS,GAAKsK,EAG9BtB,EAAO,EACFsB,EAAO,EAAGA,EAAO,GAAIA,IAEzB,IADAtF,EAAcsF,GAAQtB,EACjBE,EAAI,EAAGA,EAAK,GAAK1B,GAAgB8C,GAAQpB,IAC7CpE,EAAckE,KAAUsB,EAK1B,IADAtB,IAAS,EACFsB,EAx0BU,GAw0BUA,IAE1B,IADAtF,EAAcsF,GAAQtB,GAAQ,EACzBE,EAAI,EAAGA,EAAK,GAAM1B,GAAgB8C,GAAQ,EAAKpB,IACnDpE,EAAc,IAAMkE,KAAUsB,EAKhC,IAAKD,EAAO,EAAGA,GAt1BG,GAs1BmBA,IACpC7F,EAAa6F,GAAQ,EACtBnB,EAAI,EACJ,KAAOA,GAAK,KAAOhF,EAAiBgF,KAAKlD,GAAK,EAAGxB,EAAa,KAC9D,KAAO0E,GAAK,KAAOhF,EAAiBgF,KAAKlD,GAAK,EAAGxB,EAAa,KAC9D,KAAO0E,GAAK,KAAOhF,EAAiBgF,KAAKlD,GAAK,EAAGxB,EAAa,KAC9D,KAAO0E,GAAK,KAAOhF,EAAiBgF,KAAKlD,GAAK,EAAGxB,EAAa,KAQ9D,IAHAiG,GAAcvG,EAAkBwG,KAG3BxB,EAAI,EAAGA,EA91BK,GA81BYA,IAC5B/E,EAAiB+E,GAAGlD,GAAK,EACzB7B,EAAiB+E,GAAGnD,GAAK4E,GAAezB,EAAG,GAI5C0B,KA3LAC,GAxXD,WACC,IAAIC,EAGJ,IAAKA,EAAI,EAAGA,EAnUO,KAmUYA,IAE9BhI,EAtWc,MAsWOgI,GAAK,EAe3B,GAVAjH,EAAqB8D,GAAwB7D,GAAiBgD,SAC9D/C,EAAiB4D,GAAwB7D,GAAiB+C,YAG1DjD,EAAuB+D,GAAwB7D,GAAiBkD,UAEhExD,EAAe,EACfP,EAAkB,GAElBU,EAAgByF,GAAczG,EAAY,EAAG,SACxB,EAGpB,OAFAe,GAAa,OACbC,EAAgB,GAOjB,IAJAD,GAAa,EAINC,EAxVgBoH,MAwVsBrH,GAC5CwG,KAMD,IADAhH,EAAY,EACP4H,EAAI,EAAGA,EAAIE,EAAmBF,IAElC5H,EArWkBwF,MAqWJxF,GAAayC,GAAgC,IAAhBhD,EAAWmI,IAkVvDG,GAEA5I,EAAY,KACZG,EAAa,EACbC,EAAa,EAETqB,GAAmB,GACtBP,EAAkByH,EAClB1H,EAAmB,IAGnBA,EAAmB0H,EACnB3H,EAAsB,GAGvBX,GAAe,GAQhB,SAASwI,GAAqB7B,EAAM/B,EAAK6D,GACxC,IAAIjC,EAEJ,OAAK3G,IACJ6H,KACA7H,GAAe,EACM,GAAjBoB,IAMAuF,EAAIkC,GAAU/B,EAAM/B,EAAK6D,KAAeA,EACrCA,EAEJzI,EACIwG,GAEJpF,GAAmB,EA9NxB,WACC,KAAwB,GAAjBH,GAAmC,MAAbtB,GAAmB,CAC/C,IAAIgJ,EAqBJ,GAhBA5C,KAvgBY,GA4gBRtF,GACHK,EAAeL,GA1gBCwF,QA+gBhBrF,EAAmBkG,GAAkBrG,IAEdQ,IACtBL,EAAmBK,GAEjBL,GA/iBc,EAyjBjB,GAPA+H,EAAQC,GAAa9H,EAAeC,EACnCH,EAnjBgB,GAojBjBK,GAAiBL,EAKbA,GAAoBO,EAAoB,CAC3CP,IACA,GACCE,IACAiF,WAM8B,KAApBnF,GACXE,SAEAA,GAAgBF,EAChBA,EAAmB,EAGnBJ,EApjBgBwF,OAkjBhBxF,EAAuC,IAA3BP,EAAWa,KAEImC,GAA+C,IAA/BhD,EAAWa,EAAe,SAStE6H,EAAQC,GAAa,EAA8B,IAA3B3I,EAAWa,IACnCG,IACAH,IAYD,IAVI6H,IACHE,GAAgB,GAChBtI,EAAkBO,GAQZG,EAvkBeoH,MAukBuBrH,GAC5CwG,MAqJDsB,GAjJF,WAEC,KAAwB,GAAjB7H,GAAmC,MAAbtB,GAAmB,CAoC/C,GAhCAoG,KAIAlF,EAAkBD,EAClBF,EAAiBK,EACjBH,EAAmB0H,EA1lBP,GA4lBR7H,GACHI,EAAkBM,GAClBL,EAAeL,GA3lBCwF,SAgmBhBrF,EAAmBkG,GAAkBrG,IAEdQ,IACtBL,EAAmBK,GA9nBH,GAioBbL,GACHE,EAAeC,EAzmBD,MA6mBdH,KAMEC,GA5oBc,GA6oBjBD,GAAoBC,EAAiB,CACrC,IAAI8H,EAGJA,EAAQC,GAAa9H,EAAe,EAAIJ,EACvCG,EAlpBgB,GAupBjBI,GAAiBJ,EAAkB,EACnCA,GAAmB,EACnB,GACCC,IACAiF,WAM6B,KAAnBlF,GACXF,EAAsB,EACtBC,EAAmB0H,EACnBxH,IACI6H,IACHE,GAAgB,GAChBtI,EAAkBO,QAEc,GAAvBH,GAKNiI,GAAa,EAAkC,IAA/B3I,EAAWa,EAAe,MAC7C+H,GAAgB,GAChBtI,EAAkBO,GAEnBA,IACAG,MAKAN,EAAsB,EACtBG,IACAG,KAQD,KAAOA,EAxqBeoH,MAwqBuBrH,GAC5CwG,MAsDDuB,GACoB,GAAjB9H,IACwB,GAAvBN,GACHiI,GAAa,EAAkC,IAA/B3I,EAAWa,EAAe,IAC3C+H,GAAgB,GAChB7I,GAAe,GAETwG,EAAIkC,GAAU/B,EAAMH,EAAI5B,EAAK6D,EAAYjC,KArB9CxG,GAAe,EACR,GAuBV,SAAS0I,GAAU/B,EAAM/B,EAAK6D,GAC7B,IAAIjC,EAAGnB,EAAG+C,EAGV,IADA5B,EAAI,EACgB,MAAb7G,GAAqB6G,EAAIiC,GAAW,CAK1C,KAJApD,EAAIoD,EAAYjC,GACR7G,EAAU8E,MACjBY,EAAI1F,EAAU8E,KAEV2D,EAAI,EAAGA,EAAI/C,EAAG+C,IAClBzB,EAAK/B,EAAM4B,EAAI4B,GAAKzI,EAAU+E,IAAI/E,EAAUiF,IAAMwD,GAMlD,IAAIjD,EADL,GAHAxF,EAAUiF,KAAOS,EACjB1F,EAAU8E,KAAOY,EACjBmB,GAAKnB,EACgB,GAAjB1F,EAAU8E,IAEbU,EAAIxF,EACJA,EAAYA,EAAU6E,KACtBU,GAAgBC,GAIlB,GAAIqB,GAAKiC,EACR,OAAOjC,EAER,GAAIzG,EAAaD,EAAY,CAK5B,KAJAuF,EAAIoD,EAAYjC,GACR1G,EAAaC,IACpBsF,EAAIvF,EAAaC,GAEbqI,EAAI,EAAGA,EAAI/C,EAAG+C,IAClBzB,EAAK/B,EAAM4B,EAAI4B,GAAKjF,GAAWpD,EAAaqI,GAE7C5B,GAAKnB,EACDvF,IAFJC,GAAcsF,KAGbvF,EAAaC,EAAa,GAE5B,OAAOyG,EAoGR,SAAS0B,KACR,IAAI1B,EAGJ,IAAKA,EAAI,EAAGA,EA/2BKqB,IA+2BYrB,IAAKlF,EAAckF,GAAGnD,GAAK,EACxD,IAAKmD,EAAI,EAAGA,EA/2BK,GA+2BYA,IAAKjF,EAAciF,GAAGnD,GAAK,EACxD,IAAKmD,EAAI,EAAGA,EA/2BM,GA+2BYA,IAAK9E,EAAY8E,GAAGnD,GAAK,EAEvD/B,EAp3BmB,KAo3BU+B,GAAK,EAClCR,EAAcC,EAAiB,EAC/BN,EAAeC,EAAgBC,EAAiB,EAChDC,EAAY,EACZC,EAAe,EAShB,SAASoG,GACR7C,EACA8C,GAIA,IAHA,IAAIzL,EAAIuE,EAASkH,GACbb,EAAIa,GAAK,EAENb,GAAKpG,IAEPoG,EAAIpG,GACPuE,GAAYJ,EAAMpE,EAASqG,EAAI,GAAIrG,EAASqG,KAC5CA,KAGG7B,GAAYJ,EAAM3I,EAAGuE,EAASqG,MAIlCrG,EAASkH,GAAKlH,EAASqG,GACvBa,EAAIb,EAGJA,IAAM,EAEPrG,EAASkH,GAAKzL,EAwGf,SAASuK,GAAc5B,EACtBrC,GACA,IAEI6D,EACAnB,EAHA0C,EAAY,IAAIvE,MAAMwE,IACtBvB,EAAO,EAOX,IAAKD,EAAO,EAAGA,GA9gCG,GA8gCmBA,IACpCC,EAASA,EAAO9F,EAAa6F,EAAO,IAAO,EAC3CuB,EAAUvB,GAAQC,EAUnB,IAAKpB,EAAI,EAAGA,GAAK1C,EAAU0C,IAAK,CAC/B,IAAI/B,EAAM0B,EAAKK,GAAGlD,GACP,GAAPmB,IAGJ0B,EAAKK,GAAGnD,GAAK4E,GAAeiB,EAAUzE,KAAQA,KAehD,SAAS2E,GAAeC,GACvB,IAGI7C,EAAGC,EAHHN,EAAOkD,EAAK7F,SACZ8F,EAAQD,EAAK5F,YACbG,EAAQyF,EAAKzF,MAEbE,GAAY,EACZyF,EAAO3F,EASX,IAHA5B,EAAe,EACfC,EAhjCmB,IAkjCduE,EAAI,EAAGA,EAAI5C,EAAO4C,IACJ,GAAdL,EAAKK,GAAGnD,IACXtB,IAAWC,GAAgB8B,EAAW0C,EACtCtE,EAAUsE,GAAK,GAEfL,EAAKK,GAAGlD,GAAK,EAQf,KAAOtB,EAAe,GAAG,CACxB,IAAIwH,EAAOzH,IAAWC,GAAiB8B,EAAW,IAAMA,EAAW,EACnEqC,EAAKqD,GAAMnG,GAAK,EAChBnB,EAAUsH,GAAQ,EAClB3G,IACa,MAATyG,IACHxG,GAAkBwG,EAAME,GAAMlG,IAQhC,IALA+F,EAAKvF,SAAWA,EAKX0C,EAAIxE,GAAgB,EAAGwE,GAAK,EAAGA,IACnCwC,GAAe7C,EAAMK,GAKtB,GACCA,EAAIzE,EAhmCa,GAimCjBA,EAjmCiB,GAimCQA,EAASC,KAClCgH,GAAe7C,EAlmCE,GAomCjBM,EAAI1E,EApmCa,GAumCjBA,IAAWE,GAAgBuE,EAC3BzE,IAAWE,GAAgBwE,EAG3BN,EAAKoD,GAAMlG,GAAK8C,EAAKK,GAAGnD,GAAK8C,EAAKM,GAAGpD,GAEjCnB,EAAUsE,GAAKtE,EAAUuE,GAAK,EACjCvE,EAAUqH,GAAQrH,EAAUsE,GAE5BtE,EAAUqH,GAAQrH,EAAUuE,GAAK,EAClCN,EAAKK,GAAGlD,GAAK6C,EAAKM,GAAGnD,GAAKiG,EAG1BxH,EApnCiB,GAonCQwH,IACzBP,GAAe7C,EArnCE,SAunCTnE,GAAgB,GAEzBD,IAAWE,GAAgBF,EAznCT,GA06BnB,SAAwBsH,GACvB,IAMII,EACAjD,EAAGC,EACHkB,EACA+B,EACAC,EAVAxD,EAAOkD,EAAK7F,SACZoG,EAAQP,EAAK3F,WACbmG,EAAOR,EAAK1F,WACZG,EAAWuF,EAAKvF,SAChBD,EAAawF,EAAKxF,WAClByF,EAAQD,EAAK5F,YAMbqG,EAAW,EAEf,IAAKnC,EAAO,EAAGA,GAv7BG,GAu7BmBA,IACpC7F,EAAa6F,GAAQ,EAOtB,IAFAxB,EAAKpE,EAASE,IAAeqB,GAAK,EAE7BmG,EAAIxH,EAAe,EAAGwH,EAp7BR,IAo7B2BA,KAE7C9B,EAAOxB,EAAKA,EADZK,EAAIzE,EAAS0H,IACOnG,IAAIA,GAAK,GAClBO,IACV8D,EAAO9D,EACPiG,KAED3D,EAAKK,GAAGlD,GAAKqE,EAGTnB,EAAI1C,IAGRhC,EAAa6F,KACb+B,EAAQ,EACJlD,GAAKqD,IACRH,EAAQE,EAAMpD,EAAIqD,IACnBF,EAAIxD,EAAKK,GAAGnD,GACZR,GAAe8G,GAAKhC,EAAO+B,GACd,MAATJ,IACHxG,GAAkB6G,GAAKL,EAAM9C,GAAGlD,GAAKoG,KAEvC,GAAgB,GAAZI,EAAJ,CAMA,EAAG,CAEF,IADAnC,EAAO9D,EAAa,EACS,GAAtB/B,EAAa6F,IACnBA,IACD7F,EAAa6F,KACb7F,EAAa6F,EAAO,IAAM,EAC1B7F,EAAa+B,KAIbiG,GAAY,QACJA,EAAW,GAOpB,IAAKnC,EAAO9D,EAAoB,GAAR8D,EAAWA,IAElC,IADAnB,EAAI1E,EAAa6F,GACL,GAALnB,IACNC,EAAI1E,IAAW0H,IACP3F,IAEJqC,EAAKM,GAAGnD,IAAMqE,IACjB9E,IAAgB8E,EAAOxB,EAAKM,GAAGnD,IAAM6C,EAAKM,GAAGpD,GAC7C8C,EAAKM,GAAGpD,GAAKsE,GAEdnB,MAsIFuD,CAAeV,GAGftB,GAAc5B,EAAMrC,GASrB,SAASkG,GAAc7D,EACtBrC,GACA,IAAI0C,EAEAyD,EADAC,GAAW,EAEXC,EAAUhE,EAAK,GAAG7C,GAClB8G,EAAQ,EACRC,EAAY,EACZC,EAAY,EAQhB,IANe,GAAXH,IACHE,EAAY,IACZC,EAAY,GAEbnE,EAAKrC,EAAW,GAAGR,GAAK,MAEnBkD,EAAI,EAAGA,GAAK1C,EAAU0C,IAC1ByD,EAASE,EACTA,EAAUhE,EAAKK,EAAI,GAAGlD,KAChB8G,EAAQC,GAAaJ,GAAUE,IAE5BC,EAAQE,EAChB5I,EAAYuI,GAAQ5G,IAAM+G,EACR,GAAVH,GACJA,GAAUC,GACbxI,EAAYuI,GAAQ5G,KACrB3B,EA3pCe,IA2pCU2B,MACf+G,GAAS,GACnB1I,EA5pCiB,IA4pCU2B,KAE3B3B,EA7pCmB,IA6pCU2B,KAC9B+G,EAAQ,EAAGF,EAAUD,EACN,GAAXE,GACHE,EAAY,IACZC,EAAY,GACFL,GAAUE,GACpBE,EAAY,EACZC,EAAY,IAEZD,EAAY,EACZC,EAAY,IASf,SAASC,GAAcpE,EACtBrC,GACA,IAAI0C,EAEAyD,EADAC,GAAW,EAEXC,EAAUhE,EAAK,GAAG7C,GAClB8G,EAAQ,EACRC,EAAY,EACZC,EAAY,EAQhB,IALe,GAAXH,IACHE,EAAY,IACZC,EAAY,GAGR9D,EAAI,EAAGA,GAAK1C,EAAU0C,IAG1B,GAFAyD,EAASE,EACTA,EAAUhE,EAAKK,EAAI,GAAGlD,OAChB8G,EAAQC,GAAaJ,GAAUE,GAArC,CAEO,GAAIC,EAAQE,EAClB,GAAKpE,GAAc+D,EAAQvI,SAAkC,KAAT0I,QAChC,GAAVH,GACNA,GAAUC,IACbhE,GAAc+D,EAAQvI,GACtB0I,KAGDlE,GA/sCe,GA+sCYxE,GAC3B0E,GAAcgE,EAAQ,EAAG,IACfA,GAAS,IACnBlE,GAjtCiB,GAitCYxE,GAC7B0E,GAAcgE,EAAQ,EAAG,KAEzBlE,GAntCmB,GAmtCYxE,GAC/B0E,GAAcgE,EAAQ,GAAI,IAE3BA,EAAQ,EACRF,EAAUD,EACK,GAAXE,GACHE,EAAY,IACZC,EAAY,GACFL,GAAUE,GACpBE,EAAY,EACZC,EAAY,IAEZD,EAAY,EACZC,EAAY,IAoEf,SAASzB,GAAgB2B,GACxB,IAAIC,EAAUC,EACVC,EACAC,EAmCCvF,EAFL,GA/BAuF,EAAa9J,EAAeP,EAC5BgC,EAAaG,GAAkBC,EAG/ByG,GAAezH,GAIfyH,GAAexH,GAUf+I,EAlFD,WACC,IAAIA,EAgBJ,IAbAX,GAAc1I,EAAeK,EAAWmC,UACxCkG,GAAczI,EAAeK,EAAWkC,UAGxCsF,GAAevH,GASV8I,EAAcE,GAAkBF,GAAe,GACF,GAA7CjJ,EAAYsD,GAAa2F,IAAcrH,GADWqH,KAQvD,OAJA9H,GAAe,GAAK8H,EAAc,GAAK,EAAI,EAAI,EAIxCA,EAyDOG,IAIdJ,EAAe5H,EAAiB,EAAI,GAAM,KAD1C2H,EAAY5H,EAAc,EAAI,GAAM,KASnC4H,EAAWC,GACRE,EAAa,GAAKH,GAClBlK,GAAmB,EAoBtB,IAXA6F,GAAc,EAA0BoE,EAAK,GAC7CO,KACAnF,GAAcgF,GACdhF,IAAegF,GAQVvF,EAAI,EAAGA,EAAIuF,EAAYvF,IAC3BG,GAAavF,EAAWM,EAAkB8E,SAEjCqF,GAAeD,GACzBrE,GAAc,EAA0BoE,EAAK,GAC7CQ,GAAmBxJ,EAAkBC,KAErC2E,GAAc,EAAuBoE,EAAK,GA1F5C,SAA4BS,EAAQC,EAAQC,GAC3C,IAAIC,EASJ,IAHAhF,GAAc6E,EAAS,IAAK,GAC5B7E,GAAc8E,EAAS,EAAG,GAC1B9E,GAAc+E,EAAU,EAAG,GACtBC,EAAO,EAAGA,EAAOD,EAASC,IAE9BhF,GAAc1E,EAAYsD,GAAaoG,IAAO9H,GAAI,GAInDiH,GAAcjJ,EAAe2J,EAAS,GAGtCV,GAAchJ,EAAe2J,EAAS,GAwErCG,CAAmB1J,EAAWmC,SAAW,EACxClC,EAAWkC,SAAW,EACtB6G,EAAc,GACfK,GAAmB1J,EAAeC,IAGnC2G,KAEW,GAAPsC,GACHO,KAOF,SAASnC,GACRtC,EACAgF,GA2BA,GA1BAnL,EAAUqC,KAAkB8I,EAChB,GAARhF,EAEHhF,EAAcgK,GAAIjI,MAGlBiD,IAKAhF,EAAca,EAAgBmJ,GA14Cb,IA04CkC,GAAGjI,KACtD9B,EAAc8E,GAAWC,IAAOjD,KAEhCnD,EAAUuC,KAAmB6D,EAC7B3D,GAAaC,GAEdA,IAAiB,EAGS,IAAN,EAAfJ,KACJD,EAAaG,KAAoBC,EACjCA,EAAY,EACZC,EAAe,GAGZxB,EAAkB,GAA+B,IAAV,KAAfoB,GAA4B,CAEvD,IAEI+I,EAFAC,EAA4B,EAAfhJ,EACbiJ,EAAY3K,EAAeP,EAG/B,IAAKgL,EAAQ,EAAGA,EA55CA,GA45CqBA,IACpCC,GAAcjK,EAAcgK,GAAOlI,IAAM,EAAIyB,GAAgByG,IAM9D,GAJAC,IAAe,EAIX/I,EAAgBS,SAASV,EAAe,IAC3CgJ,EAAatI,SAASuI,EAAY,GAClC,OAAO,EAET,OAAwBC,MAAhBlJ,GAt8Ca,MAu8CpBC,EAUF,SAASuI,GACRW,EACAC,GACA,IAAItF,EACAgF,EAKA1D,EACAgC,EALAiC,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAO,EAIX,GAAoB,GAAhBxJ,EAAmB,GACN,IAAN,EAALqJ,KACJG,EAAOzJ,EAAawJ,MACrBT,EAAuB,IAAlBnL,EAAU0L,KACG,IAAN,EAAPG,GACJ9F,GAAcoF,EAAIK,IAKlBzF,IADA0B,EAAOzF,EAAgBmJ,IA18CP,IA28CoB,EAAGK,GAE1B,IADb/B,EAAQ/E,GAAgB+C,KAGvBxB,GADAkF,GAAMjJ,EAAgBuF,GACJgC,GAOnB1D,GAHA0B,EAAOvB,GAFPC,EAAOpG,EAAU4L,MAKGF,GAEP,IADbhC,EAAQ9E,GAAgB8C,KAGvBxB,GADAE,GAAQhE,EAAcsF,GACFgC,IAGtBoC,IAAS,QACDH,EAAKrJ,GAEd0D,GA/9CmB,IA+9CUyF,GAQ9B,SAASvF,GACRlK,EACAoB,GAKIgD,EARc,GAQgBhD,GAEjCsI,GADAvF,GAAenE,GAASoE,GAExBD,EAAcnE,GAXG,GAWsBoE,EACvCA,GAAgBhD,EAZC,KAcjB+C,GAAcnE,GAASoE,EACvBA,GAAgBhD,GASlB,SAAS2K,GACRL,EACAnD,GACA,IAAIwH,EAAM,EACV,GACCA,GAAc,EAAPrE,EACPA,IAAS,EACTqE,IAAQ,UACExH,EAAM,GACjB,OAAOwH,GAAO,EAMf,SAASlB,KACJzK,EAAe,EAClBsF,GAAcvF,GACJC,EAAe,GACzBkF,GAAanF,GAEdA,EAAa,EACbC,EAAe,EAmBhB,OAAO,SAAiB4L,EAAKC,GAC5B,IAAI9G,EAAG+C,EAEPrF,EAAmBmJ,EACnBlJ,GAAkB,EACE,oBAATmJ,IACVA,EAplDsB,GAsKxB,SAA2BA,GAC1B,IAAI9G,EAYJ,GAVK8G,EAEIA,EAAQ,EAChBA,EAAQ,EACAA,EAAQ,IAChBA,EAAQ,GAJRA,EA1KsB,EAgLvB/K,EAAkB+K,EAClBtM,GAAe,EACfmB,GAAa,EACK,MAAdmC,GAAJ,CAUA,IAPAzD,EAAiBC,EAAYC,EAAY,KACzCuD,GAAa,IAAIwB,MAnLE,MAoLnB1E,EAAa,IAAI0E,MAnLI,OAoLrBzE,EAAY,IAAIyE,MA/KK,MAgLrBxE,EAAY,IAAIwE,MAAMyH,OACtBhM,EAAW,IAAIuE,MAAM,OACrBrD,EAAgB,IAAIqD,MA9ID,KA+IdU,EAAI,EAAGA,EA/IO,IA+IYA,IAC9B/D,EAAc+D,GAAK,IAAIjC,GAExB,IADA7B,EAAgB,IAAIoD,MAAM,IACrBU,EAAI,EAAGA,EAAI,GAAqBA,IACpC9D,EAAc8D,GAAK,IAAIjC,GAExB,IADA5B,EAAmB,IAAImD,MAAMqD,KACxB3C,EAAI,EAAGA,EAAI2C,IAAiB3C,IAChC7D,EAAiB6D,GAAK,IAAIjC,GAE3B,IADA3B,EAAmB,IAAIkD,MA5JN,IA6JZU,EAAI,EAAGA,EA7JK,GA6JYA,IAC5B5D,EAAiB4D,GAAK,IAAIjC,GAE3B,IADA1B,EAAc,IAAIiD,MAAM,IACnBU,EAAI,EAAGA,EAAI,GAAsBA,IACrC3D,EAAY2D,GAAK,IAAIjC,GACtBzB,EAAa,IAAI4B,GACjB3B,EAAa,IAAI2B,GACjB1B,EAAc,IAAI0B,GAClBzB,EAAe,IAAI6C,MAAMwE,IACzBpH,EAAW,IAAI4C,MAAM,KACrBzC,EAAY,IAAIyC,MAAM,KACtBxC,EAAkB,IAAIwC,MAAM0D,KAC5BjG,EAAgB,IAAIuC,MAAM,KAC1BtC,EAAkB,IAAIsC,MA9KA,IA+KtBrC,EAAgB,IAAIqC,MA3KH,IA4KjBpC,EAAe,IAAIoC,MAAMzB,SAASwI,QAg4ClCW,CAAkBF,GAIlB,IAFA,IAAIxF,EAAO,IAAIhC,MAAM,MACjB2H,EAAO,IACHjH,EAAImD,GAAqB7B,EAAM,EAAGA,EAAKrJ,SAAW,GAAG,CAC5D,IAAIiP,EAAO,IAAI5H,MAAMU,GACrB,IAAK+C,EAAI,EAAGA,EAAI/C,EAAG+C,IAClBmE,EAAKnE,GAAKoE,OAAOC,aAAa9F,EAAKyB,IAEpCkE,EAAKA,EAAKhP,QAAUiP,EAAKG,KAAK,IAG/B,OADA3J,EAAmB,KACZuJ,EAAKI,KAAK,KAnnDJ,GCKTC,GAAe,SAACC,EAAIC,EAAIC,GAC5B,IACMC,GAAY,EAALH,IAAa,EAAMC,GAAM,EAChCG,GAAY,GAALH,IAAa,EAAMC,GAAM,EAChCG,EAAU,GAALH,EACPI,EAAI,GAKR,OAJAA,GAAKC,GAAgB,GALVP,GAAM,GAMjBM,GAAKC,GAAgB,GAALJ,GAChBG,GAAKC,GAAgB,GAALH,GAChBE,GAAKC,GAAgB,GAALF,IAIZE,GAAa,SAACnJ,GAClB,OAAIA,EAAI,GACCwI,OAAOC,aAAa,GAAKzI,IAElCA,GAAK,IACG,GACCwI,OAAOC,aAAa,GAAKzI,IAElCA,GAAK,IACG,GACCwI,OAAOC,aAAa,GAAKzI,GAGzB,IADTA,GAAK,IAEI,IAEA,GAALA,EACK,IAEF,KAGM,SAASoJ,GAAgCC,GACtD,IAAMC,EAAqBC,SAASC,mBAAmBH,IAEvD,MAAO,wCArDQ,SAAA7S,GAEf,IADA,IAAI0S,EAAI,GACC7H,EAAI,EAAGA,EAAI7K,EAAK8C,OAAQ+H,GAAK,EAChCA,EAAI,GAAK7K,EAAK8C,OAChB4P,GAAKP,GAAanS,EAAKqM,WAAWxB,GAAI7K,EAAKqM,WAAWxB,EAAI,GAAI,GACrDA,EAAI,GAAK7K,EAAK8C,OACvB4P,GAAKP,GAAanS,EAAKqM,WAAWxB,GAAI,EAAG,GAEzC6H,GAAKP,GAAanS,EAAKqM,WAAWxB,GAAI7K,EAAKqM,WAAWxB,EAAI,GACxD7K,EAAKqM,WAAWxB,EAAI,IAG1B,OAAO6H,EAwCeO,CAAShO,GAAQ6N,EAAoB,ICvD7D,IAAMI,GAAgB,CACrBC,UAAU,GAEI,SAASC,GAAiBC,EAASC,GAAS,IAClDH,GAAaG,GAAkBJ,IAA/BC,SAEFI,EAAQF,EAAQtQ,QAAQ,aAC9B,GAAIwQ,EAAQ,EACX,MAAO,CAAE9O,OAAO,GAEjB,IAAM+O,EAAaH,EAAQxQ,UAAU,EAAG0Q,GACpCE,EAAYJ,EAAQxQ,UAAU0Q,EAAQ,YAAYzQ,QAEhD4Q,EAAYF,EAAWG,MAAM,MAC7BC,EAAa,GACnBF,EAAUG,SAAQ,SAAA7T,GAEjB,IADAA,EAAOA,EAAK8T,QACHnR,WAAW,KAAM,CACzB,IAAMoR,EAAa/T,EAAK+C,QAAQ,KAChC,GAAIgR,EAAa,EAAG,CACnB,IAAMzV,EAAO0B,EAAK6C,UAAU,GAC5B+Q,EAAWtV,IAAQ,MACb,CACN,IAAMA,EAAO0B,EAAK6C,UAAU,EAAGkR,GAAYD,OACrCpS,EAAQ1B,EAAK6C,UAAUkR,GAAYD,OACzCF,EAAWtV,GAAQoD,OAIlByR,GAAYS,EAAWtW,QAC1BmW,EAAY,SAAWG,EAAWtW,MAAQ,KAAOmW,GAElDvT,QAAQC,IAAIyT,GACZ,IAAMI,EAAWpB,GAAgCa,GAEjD,MAAO,CACNhP,OAAO,EACPzE,KAAM4T,EACNvP,IAAK2P,G,IC1BcC,G,4MAMpB5T,MAAQ,CACPC,SAAS,EACTsB,OAAO,EACPqC,cAAUiQ,G,EAuBXC,a,sBAAe,8BAAA5U,EAAA,6DACd,EAAKqB,SAAS,CACbN,SAAS,EACTsB,OAAO,EACPqC,cAAUiQ,IAJG,kBAOUzU,IAAMC,IAAN,gBAAmB,EAAKxC,MAAMkX,MAAMC,OAAOC,OAAS,CAAEC,QAAS,CAAEC,cAAc,UAAD,OAAYrV,EAAWP,WAP/G,OASW,OAFlBe,EAPO,QASAC,QACZM,QAAQC,IAAIR,GACNsE,EAAW,CAChB3G,MAAOqC,EAASK,KAAK1C,MACrBmX,WAAY9U,EAASK,KAAKyU,WAC1BC,SAAU/U,EAASK,KAAKqT,QAAQsB,IAAIvB,KAErClT,QAAQC,IAAI8D,EAASyQ,UACrB,EAAK9T,SAAS,CAAEqD,WAAU3D,SAAS,EAAOsB,OAAO,MAGjD1B,QAAQC,IAAIR,GACZ,EAAKiB,SAAS,CAAEgB,OAAO,EAAMtB,SAAS,EAAO2D,cAAUiQ,KArB3C,gDAwBT,KAAIvU,UAAoC,MAAxB,KAAIA,SAASC,QAChCT,EAAWH,QAEZkB,QAAQC,IAAR,MACA,EAAKS,SAAS,CAAEgB,OAAO,EAAMtB,SAAS,EAAO2D,cAAUiQ,IA5B1C,yD,kEApBdjX,KAAK2X,mB,yCAEa7X,GACdE,KAAKC,MAAMkX,MAAMC,OAAOC,QAAUvX,EAAUqX,MAAMC,OAAOC,OAC5DrX,KAAK2X,mB,uCAKN,IAAMN,EAAQrX,KAAKC,MAAMkX,MAAMC,OAAOC,MACjCA,GAILjV,EAAmBd,MAAM+V,GACNnV,EAAWD,UAE7BjC,KAAKkX,gBANLlX,KAAKC,MAAMqG,QAAQC,KAAK,O,+BAyChB,IAAD,OACFhD,EAAarB,EAAWD,SAC9B,OACC,6BACC,kBAAC,EAAD,CAAW5B,MAAOL,KAAKoD,MAAMC,QAAU,mBAAqBrD,KAAKoD,MAAMuB,MAAQ,QAAU3E,KAAKoD,MAAM4D,SAAWhH,KAAKoD,MAAM4D,SAAS3G,MAAQ,qBAC3I,kBAAC,EAAD,CAAiBN,MAAOwD,EAAYE,QAAS,kBAAM,EAAKxD,MAAMqG,QAAQC,KAAK,QAC3E,kBAAC,KAAD,CAAI1C,UAAW7D,KAAKoD,MAAMC,SACzB,kBAAC,OAAD,KACC,kBAACc,EAAA,EAAD,MADD,WAGA,kBAAC,OAAD,KACC,kBAAC,KAAD,CAAIN,UAAW7D,KAAKoD,MAAMuB,OACzB,kBAAC,OAAD,KACC,kBAACb,EAAA,EAAD,MADD,SAGA,kBAAC,OAAD,KACC,kBAAC,OAAD,CAAMD,YAAa7D,KAAKoD,MAAM4D,WAC5B,kBACA,kBAAC,KAAD,CAAInD,UAAoF,IAAzE,EAAKT,MAAM4D,SAASyQ,SAASG,QAAO,SAAAC,GAAO,OAAIA,EAAQrQ,SAAO3B,QAC5E,kBAAC,OAAD,mBAGA,kBAAC,OAAD,KACC,yBAAK/E,UAAU,QACb,EAAKsC,MAAM4D,SAASyQ,SAASC,KAAI,SAACG,EAASjK,GAAV,OACjC,kBAAC,GAAD,eAAqBkK,IAAKlK,EAAGnG,GAAImG,GAAOiK,sB,GAzFjBtX,IAAMC,WCXtBuX,G,uKAGnB,OACC,6BACC,kBAAC,EAAD,CAAW1X,MAAM,SADlB,qC,GAJmCE,IAAMC,W,8BCavBwX,G,4MAMpB5U,MAAQ,CACPC,SAAS,EACTd,SAAS,EACT0V,OAAO,EACP3S,SAAS,G,EAyBV4S,W,uCAAa,WAAO/H,GAAP,iBAAA7N,EAAA,6DACRC,GAAU,EADF,kBAGYC,IAAMC,IAAN,cAAyB,CAAE2U,OAAQ,CAAEjH,UAHjD,OAIa,OADlBzN,EAHK,QAIEC,SACZJ,GAAU,EACVL,EAAWZ,MAAMoB,EAASK,KAAKoV,QANrB,gDAUXlV,QAAQC,IAAR,MAVW,QAYZ,EAAKS,SAAS,CACbpB,UAASc,SAAS,IAbP,yD,wDAgBb+U,eAAiB,WAChB,EAAKzU,SAAS,CACbN,SAAS,EACTd,SAAS,EACT+C,SAAS,EACT2S,OAAO,GAJR,sBAKG,sBAAA3V,EAAA,sEAEID,IAFJ,OAGF,EAAKsB,SAAS,CAAEN,SAAS,EAAOd,SAAS,IAHvC,6C,EAMJ8V,aAAe,WACd,EAAKpY,MAAMqG,QAAQC,KAAK,M,EAEzB+R,aAAe,WACVlW,EAAmBH,SACtB,EAAKhC,MAAMqG,QAAQC,KAAnB,gBAAiCnE,EAAmBT,SAEpD,EAAK1B,MAAMqG,QAAQC,KAAK,M,kEAzDrBrE,EAAWD,UAEdjC,KAAKC,MAAMqG,QAAQC,KAAK,KAEzB,IACM4J,EADQoI,KAAYzW,MAAM9B,KAAKC,MAAM4C,SAAS2V,QACjCrI,KACdA,GAOA/N,EAAmBH,UACtBjC,KAAK2D,SAAS,CAAE2B,SAAS,IAE1BtF,KAAK2D,SAAS,CAAEsU,OAAO,IACvBjY,KAAKkY,WAAW/H,IAVhBnQ,KAAK2D,SAAS,CACbN,SAAS,EACTd,SAAS,EACT+C,SAAS,M,+BAkDF,IAAD,OACR,OACC,6BACC,kBAAC,EAAD,CAAWjF,MAAM,kBACjB,kBAAC,EAAD,CAAYN,MAAM,EAAM0D,QAAS,kBAAM,EAAK4U,gBAAgBhY,MAAM,iBACjE,kBAAC,KAAD,CAAIwD,UAAW7D,KAAKoD,MAAMC,SACzB,kBAAC,OAAD,KACC,kBAAC,KAAD,CAAIQ,UAAW7D,KAAKoD,MAAM6U,OACzB,kBAAC,OAAD,KACC,kBAACxX,EAAD,CAAwBE,KAAM,kBAACwD,EAAA,EAAD,CAAkBC,KAAK,SAAWxD,QAAQ,kBAAxE,qCAID,kBAAC,OAAD,KACC,kBAACH,EAAD,CAAwBE,KAAM,kBAACwD,EAAA,EAAD,CAAkBC,KAAK,SAAWxD,QAAQ,oBAAxE,+CAMH,kBAAC,OAAD,KACC,kBAAC,KAAD,CAAIiD,UAAW7D,KAAKoD,MAAMb,SACzB,kBAAC,OAAD,KACC,kBAAC9B,EAAD,CAAwBC,UAAU,aAAaC,KAAM,kBAAC8X,GAAA,EAAD,CAAqB3X,UAAU,eAAiBF,QAAQ,YAA7G,qDAEA,kBAAC,OAAD,CAAMiD,UAAW7D,KAAKoD,MAAMkC,SAC1B,6BADF,SACc,sCADd,2CAIA,kBAACvB,EAAA,EAAD,KACC,kBAAC,KAAD,CAAIF,UAAW7D,KAAKoD,MAAMkC,SACzB,kBAAC,OAAD,KACC,kBAACtB,EAAA,EAAD,CAAQC,MAAM,UAAUC,QAAS,kBAAM,EAAKmU,iBAA5C,QACA,kBAACrU,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKoU,iBAAhE,YAED,kBAAC,OAAD,KACC,kBAACtU,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKmU,iBAAhE,YAKJ,kBAAC,OAAD,KACC,kBAAC5X,EAAD,CAAwBC,UAAU,gBAAgBC,KAAM,kBAACmD,EAAA,EAAD,CAAsBhD,UAAU,eAAiBF,QAAQ,uBAAjH,2BACyB,oCADzB,kBAGA,kBAACmD,EAAA,EAAD,KACC,kBAACC,EAAA,EAAD,CAAQC,MAAM,UAAUC,QAAS,kBAAM,EAAKmU,iBAA5C,QACA,kBAACrU,EAAA,EAAD,CAAQ/C,QAAQ,YAAYgD,MAAM,UAAUC,QAAS,kBAAM,EAAKkU,mBAAhE,oB,GAxHyC7X,IAAMC,WCZ1C,SAASkY,KACvB,OACC,gCACC,kBAAC1X,EAAA,EAAD,CAAYC,QAAQ,UAAUH,UAAU,cAAxC,kC,ICGG6X,G,uKAIJ,OACC,yBAAK7X,UAAU,gBACd,kBAAC,IAAD,KACC,kBAAC,IAAD,CAAO8X,KAAK,eAAeC,UAAWC,KACtC,kBAAC,IAAD,CAAOF,KAAK,QAAQC,UAAWE,KAC/B,kBAAC,IAAD,CAAOC,OAAK,EAACJ,KAAK,KACjB,kBAAC,GAAD,OAED,kBAAC,IAAD,CAAOA,KAAK,KAAZ,cAKD,kBAACF,GAAD,W,GAjBsBnY,IAAMC,WAsBjB0G,eAAWyR,I,SCnBNM,QACW,cAA7BrW,OAAOC,SAASqW,UAEe,UAA7BtW,OAAOC,SAASqW,UAEhBtW,OAAOC,SAASqW,SAAS/B,MACvB,2DCZN,IAAMgC,GAAcF,QACW,cAA7BrW,OAAOC,SAASqW,UAEa,UAA7BtW,OAAOC,SAASqW,UAEhBtW,OAAOC,SAASqW,SAAS/B,MACvB,2DAGJ3U,IAAM4W,SAASC,QAAUF,GAAc,wBAA0B,qDAEjEG,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,KAAD,KAAQ,kBAAC,GAAD,QAEVxS,SAASyS,eAAe,SD8GpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAArV,GACL1B,QAAQ0B,MAAMA,EAAMsV,a","file":"static/js/main.ca5dc11b.chunk.js","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Dialog, DialogTitle } from '@material-ui/core';\r\n\r\nexport default class CommonDialog extends React.Component {\r\n\tstatic propTypes = {\r\n\t\topen: PropTypes.bool.isRequired,\r\n\t\ttitle: PropTypes.string.isRequired,\r\n\t\tchildren: PropTypes.any,\r\n\t\tonReset: PropTypes.func\r\n\t};\r\n\tcomponentDidUpdate(prevProps) {\r\n\t\tif (prevProps.open !== this.props.open && this.props.open) {\r\n\t\t\tthis.props.onReset && this.props.onReset();\r\n\t\t}\r\n\t}\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t<Dialog open={this.props.open} {...this.props}>\r\n\t\t\t\t\t<DialogTitle>{this.props.title}</DialogTitle>\r\n\t\t\t\t\t{this.props.children}\r\n\t\t\t\t</Dialog>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n};\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport clsx from 'clsx';\r\nimport { DialogContent, Typography, DialogContentText } from '@material-ui/core';\r\nexport default function LargeIconDialogContent({ iconClass, icon, caption, children }) {\r\n\treturn (\r\n\t\t<DialogContent>\r\n\t\t\t<div className={clsx(\"align-center\", iconClass)}>\r\n\t\t\t\t{icon}\r\n\t\t\t\t<Typography variant=\"h5\">{caption}</Typography>\r\n\t\t\t</div>\r\n\t\t\t<DialogContentText>\r\n\t\t\t\t{children}\r\n\t\t\t</DialogContentText>\r\n\t\t</DialogContent>\r\n\t);\r\n};\r\nLargeIconDialogContent.propTypes = {\r\n\tcenterClass: PropTypes.any,\r\n\ticon: PropTypes.element.isRequired,\r\n\tcaption: PropTypes.string.isRequired,\r\n\tchildren: PropTypes.any\r\n}","const TOKEN_NAME = \"plantuml-doc-integration-token-v1\";\r\nconst REDIRECT_DOCID_NAME = \"plantuml-doc-integration-redirect-docid\";\r\n\r\nconst create = (storage, name) => {\r\n\tconst store = (obj) => {\r\n\t\tstorage.setItem(name, JSON.stringify(obj));\r\n\t}\r\n\r\n\tconst load = () => {\r\n\t\tconst string = storage.getItem(name);\r\n\t\tif (string === null) return null;\r\n\t\treturn JSON.parse(string);\r\n\t}\r\n\r\n\tconst clear = () => {\r\n\t\tstorage.removeItem(name);\r\n\t}\r\n\r\n\tconst exists = () => {\r\n\t\treturn storage.getItem(name) !== null;\r\n\t}\r\n\treturn { store, load, clear, exists };\r\n}\r\nexport const tokenStore = create(localStorage, TOKEN_NAME);\r\nexport const redirectDocIdStore = create(localStorage, REDIRECT_DOCID_NAME);\r\n","import axios from 'axios';\r\nexport default async function redirectToAuthUrl() {\r\n\tlet success = true;\r\n\ttry {\r\n\t\tconst response = await axios.get(`/auth/new`);\r\n\t\tif (response.status === 200) {\r\n\t\t\twindow.location.href = response.data.authUrl;\r\n\t\t} else {\r\n\t\t\tsuccess = false;\r\n\t\t}\r\n\t} catch (err) {\r\n\t\tconsole.log(err);\r\n\t\tsuccess = false;\r\n\t}\r\n\treturn success;\r\n}\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport DialogBase from '../../element/dialog/DialogBase';\r\nimport { Button, CircularProgress, DialogActions } from '@material-ui/core';\r\nimport { VpnKeyOutlined, LockOutlined, ErrorOutlineOutlined } from '@material-ui/icons';\r\nimport { If, Then, Else } from 'react-if';\r\nimport LargeIconDialogContent from '../../element/dialog/LargeIconDialogContent';\r\nimport { tokenStore, redirectDocIdStore } from '../../util/Store';\r\nimport redirectToAuthUrl from '../../util/AuthorizeRedirector';\r\n\r\n\r\nexport default class AuthorizeDialog extends React.Component {\r\n\tstatic propTypes = {\r\n\t\topen: PropTypes.bool.isRequired,\r\n\t\tonClose: PropTypes.func.isRequired\r\n\t};\r\n\tstate = {\r\n\t\tloading: false,\r\n\t\tfail: false,\r\n\t\tauthorized: false,\r\n\t};\r\n\r\n\treset() {\r\n\t\tthis.setState({\r\n\t\t\tloading: false,\r\n\t\t\tfail: false,\r\n\t\t\tauthorized: tokenStore.exists()\r\n\t\t});\r\n\t}\r\n\r\n\tunauthorize = () => {\r\n\t\ttokenStore.clear();\r\n\t\tredirectDocIdStore.clear();\r\n\t\tthis.props.onClose();\r\n\t}\r\n\r\n\tauthorize = async () => {\r\n\t\tthis.setState({\r\n\t\t\tloading: true,\r\n\t\t\tfail: false\r\n\t\t}, async () => {\r\n\t\t\tconst success = await redirectToAuthUrl();\r\n\t\t\tif (!success) {\r\n\t\t\t\tthis.setState({ loading: true, fail: true });\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<DialogBase open={this.props.open} onClose={() => this.props.onClose()} onReset={() => this.reset()} title=\"Authorization\">\r\n\t\t\t\t<If condition={this.state.loading}>\r\n\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t<If condition={this.state.fail}>\r\n\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t<LargeIconDialogContent iconClass=\"color-danger\" icon={<ErrorOutlineOutlined className=\"large-icon\" />} caption=\"Failed to connect\">\r\n\t\t\t\t\t\t\t\t\tAn error occured when connecting to the server.\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t\t<DialogActions>\r\n\t\t\t\t\t\t\t\t\t<Button color=\"primary\" onClick={() => this.props.onClose()}>Cancel</Button>\r\n\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.authorize()}>Retry</Button>\r\n\t\t\t\t\t\t\t\t</DialogActions>\r\n\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t<LargeIconDialogContent icon={<CircularProgress size=\"5rem\" />} caption=\"Please wait...\">\r\n\t\t\t\t\t\t\t\t\tYou will be redirected to Google\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t</If>\r\n\t\t\t\t\t</Then>\r\n\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t<If condition={this.state.authorized}>\r\n\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t<LargeIconDialogContent iconClass=\"color-safe\" icon={<VpnKeyOutlined className=\"large-icon\" />} caption=\"Authorized\">\r\n\t\t\t\t\t\t\t\t\tYou have authorized PlantUML Doc Integration to read your documents on Google Docs.\r\n\t\t\t\t\t\t\t\t\tIf you wish to remove your authorization token, please click <b>Unauthorize</b> below.<br /><br />\r\n\t\t\t\t\t\t\t\t\tThis does not remove permissions for PlantUML Doc Integration. You will need to do that in your Google account settings.\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t<LargeIconDialogContent iconClass=\"color-danger\" icon={<LockOutlined className=\"large-icon\" />} caption=\"Unauthorized\">\r\n\t\t\t\t\t\t\t\t\tYou need to authorize PlantUML Doc Integration to read your documents on Google Docs in order to use it.\r\n\t\t\t\t\t\t\t\t\tWe do not keep your data. We simply parse it and draw diagrams from it.<br /><br />\r\n\t\t\t\t\t\t\t\t\tYou will be automatically asked to authorize this app when you open a document. If you want to authorize it now, click the <b>Authorize</b> button below.\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t<DialogActions>\r\n\t\t\t\t\t\t\t<Button color=\"primary\" onClick={() => this.props.onClose()}>Cancel</Button>\r\n\t\t\t\t\t\t\t<If condition={this.state.authorized}>\r\n\t\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.unauthorize()} >Unauthorize</Button>\r\n\t\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.authorize()}> Authorize</Button>\r\n\t\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t</DialogActions>\r\n\t\t\t\t\t</Else>\r\n\t\t\t\t</If>\r\n\t\t\t</DialogBase >\r\n\t\t);\r\n\t};\r\n};\r\n\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { DialogContent, DialogContentText, TextField } from '@material-ui/core';\r\n\r\nexport default function InputDialogContent({ children, label, value, onChange, error }) {\r\n\treturn (\r\n\t\t<DialogContent>\r\n\t\t\t<DialogContentText>{children}</DialogContentText>\r\n\t\t\t<TextField\r\n\t\t\t\tmargin=\"normal\"\r\n\t\t\t\tautoFocus\r\n\t\t\t\tlabel={label}\r\n\t\t\t\tvalue={value}\r\n\t\t\t\tonChange={(e) => onChange(e.target.value)}\r\n\t\t\t\terror={!!error}\r\n\t\t\t\thelperText={error ? error : \" \"}\r\n\t\t\t\trequired\r\n\t\t\t\tfullWidth\r\n\t\t\t/>\r\n\t\t</DialogContent>\r\n\t);\r\n};\r\nInputDialogContent.propTypes = {\r\n\tlabel: PropTypes.string.isRequired,\r\n\tvalue: PropTypes.string.isRequired,\r\n\tonChange: PropTypes.func.isRequired,\r\n\terror: PropTypes.string.isRequired\r\n}","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport DialogBase from '../../element/dialog/DialogBase';\r\nimport { Button, DialogActions } from '@material-ui/core';\r\nimport InputDialogContent from '../../element/dialog/InputDialogContent';\r\nexport default class OpenDocumentDialog extends React.Component {\r\n\tstatic propTypes = {\r\n\t\tonClose: PropTypes.func.isRequired,\r\n\t\topen: PropTypes.bool.isRequired\r\n\t};\r\n\tstate = {\r\n\t\tinput: \"\",\r\n\t\terror: \"\"\r\n\t};\r\n\treset() {\r\n\t\tthis.setState({ input: \"\", error: \"\" })\r\n\t}\r\n\tonChangeInput(input) {\r\n\t\tthis.setState({ input, error: \"\" });\r\n\t};\r\n\tonClickClose(proceed) {\r\n\t\tif (!proceed) {\r\n\t\t\tthis.props.onClose(false);\r\n\t\t} else {\r\n\t\t\tif (this.validateInput(this.state.input)) {\r\n\t\t\t\tthis.props.onClose(this.processInput(this.state.input));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tvalidateInput(input) {\r\n\t\tif (!input) {\r\n\t\t\tthis.setState({ error: \"This is required\" });\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\tprocessInput(input) {\r\n\t\tconst prefix = 'https://docs.google.com/document/d/';\r\n\t\tif (input.startsWith(prefix)) {\r\n\t\t\tinput = input.substring(prefix.length);\r\n\t\t\tconst slash = input.indexOf('/');\r\n\t\t\tif (slash > 0) {\r\n\t\t\t\tinput = input.substring(0, slash);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn input;\r\n\t};\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<DialogBase fullWidth open={this.props.open} title=\"Open from Google Docs\" onReset={() => this.reset()}>\r\n\t\t\t\t<InputDialogContent label=\"Document Link/Id\" value={this.state.input} onChange={(v) => this.onChangeInput(v)} error={this.state.error}>\r\n\t\t\t\t\tPlease enter the document link or id\r\n\t\t\t\t</InputDialogContent>\r\n\t\t\t\t<DialogActions>\r\n\t\t\t\t\t<Button color=\"primary\" onClick={() => this.onClickClose(false)}>Cancel</Button>\r\n\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.onClickClose(true)}>Open</Button>\r\n\t\t\t\t</DialogActions>\r\n\t\t\t</DialogBase>\r\n\t\t);\r\n\t};\r\n};","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { withRouter } from 'react-router-dom';\r\nimport { AppBar, Toolbar, IconButton, Typography, Tooltip } from '@material-ui/core';\r\nimport { InsertDriveFileOutlined, SettingsApplicationsOutlined, AccountCircleOutlined } from '@material-ui/icons';\r\nimport AuthorizeDialog from '../page/auth/AuthorizeDialog';\r\nimport OpenDocumentDialog from '../page/docs/OpenDocumentDialog';\r\nclass HeaderBar extends React.Component {\r\n\tstatic propTypes = {\r\n\t\ttitle: PropTypes.string.isRequired,\r\n\t}\r\n\tstate = {\r\n\t\topenAuthorizeDialog: false,\r\n\t\topenOpenDocumentDialog: false\r\n\t}\r\n\tsetOpenDocument(openDocument) {\r\n\t\tconsole.log(openDocument);\r\n\t\tthis.setState({ openOpenDocumentDialog: false });\r\n\t\tif (openDocument) {\r\n\t\t\tthis.props.history.push(`/docs/${openDocument}`);\r\n\t\t}\r\n\t}\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<header>\r\n\t\t\t\t<AppBar position=\"static\">\r\n\t\t\t\t\t<Toolbar>\r\n\t\t\t\t\t\t<Tooltip title=\"Open Document\">\r\n\t\t\t\t\t\t\t<IconButton edge=\"start\" color=\"inherit\" onClick={() => this.setState({ openOpenDocumentDialog: true })}>\r\n\t\t\t\t\t\t\t\t<InsertDriveFileOutlined className=\"header-icon\" />\r\n\t\t\t\t\t\t\t</IconButton>\r\n\t\t\t\t\t\t</Tooltip>\r\n\r\n\t\t\t\t\t\t<Typography variant=\"h5\">\r\n\t\t\t\t\t\t\t{this.props.title}\r\n\t\t\t\t\t\t</Typography>\r\n\t\t\t\t\t\t<div className=\"toolbar-align-right\">\r\n\t\t\t\t\t\t\t<Tooltip title=\"Authorization\">\r\n\t\t\t\t\t\t\t\t<IconButton edge=\"start\" color=\"inherit\" onClick={() => this.setState({ openAuthorizeDialog: true })}>\r\n\t\t\t\t\t\t\t\t\t<AccountCircleOutlined className=\"header-icon\" />\r\n\t\t\t\t\t\t\t\t</IconButton>\r\n\t\t\t\t\t\t\t</Tooltip>\r\n\t\t\t\t\t\t\t{/* <Tooltip title=\"Settings\">\r\n\t\t\t\t\t\t\t\t<IconButton edge=\"start\" color=\"inherit\">\r\n\t\t\t\t\t\t\t\t\t<SettingsApplicationsOutlined className=\"header-icon\" />\r\n\t\t\t\t\t\t\t\t</IconButton>\r\n\t\t\t\t\t\t\t</Tooltip> */}\r\n\t\t\t\t\t\t</div>\r\n\r\n\t\t\t\t\t</Toolbar>\r\n\t\t\t\t</AppBar >\r\n\t\t\t\t<OpenDocumentDialog open={this.state.openOpenDocumentDialog} onClose={(document) => this.setOpenDocument(document)} />\r\n\r\n\t\t\t\t<AuthorizeDialog open={this.state.openAuthorizeDialog} onClose={() => this.setState({ openAuthorizeDialog: false })} />\r\n\t\t\t</header>\r\n\r\n\t\t);\r\n\t}\r\n}\r\nexport default withRouter(HeaderBar);\r\n\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nexport default function PlantImage({ src, title }) {\r\n  return (\r\n    <div>\r\n      <img alt={title ? title : \"Plant UML Diagram\"} src={src} width=\"100%\" />;\r\n    </div>\r\n  );\r\n};\r\nPlantImage.propTypes = {\r\n  src: PropTypes.string.isRequired,\r\n  title: PropTypes.string\r\n}","import React from 'react'\r\nimport PropTypes from 'prop-types';\r\nimport { Accordion, AccordionDetails, AccordionSummary, Typography } from '@material-ui/core';\r\nimport { ExpandMore } from '@material-ui/icons/';\r\nimport { If, Then, Else, When } from 'react-if';\r\nimport PlantImage from './PlantImage';\r\nexport default function PlantPaper({ valid, data, src, id }) {\r\n\treturn (\r\n\t\t<Accordion>\r\n\t\t\t<AccordionSummary expandIcon={<ExpandMore />}\r\n\t\t\t\taria-controls={`diagram${id}-content`}\r\n\t\t\t\tid={`diagram${id}-header`}>\r\n\t\t\t\t<If condition={valid}>\r\n\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t<Typography variant=\"h6\">{data.title ? data.title : \"Untitled\"}</Typography>\r\n\t\t\t\t\t</Then>\r\n\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t<Typography variant=\"h6\">Invalid Diagram</Typography>\r\n\t\t\t\t\t</Else>\r\n\t\t\t\t</If>\r\n\t\t\t</AccordionSummary>\r\n\t\t\t<When condition={valid}>\r\n\t\t\t\t<AccordionDetails>\r\n\t\t\t\t\t<PlantImage src={src} title={data.title} />\r\n\t\t\t\t</AccordionDetails>\r\n\t\t\t</When>\r\n\t\t</Accordion>\r\n\t);\r\n};\r\nPlantPaper.propTypes = {\r\n\tvalid: PropTypes.bool.isRequired,\r\n\tdata: PropTypes.object,\r\n\tsrc: PropTypes.string,\r\n\tid: PropTypes.number.isRequired\r\n}","/* eslint-disable */\n/*\n *  Modified by iTNTPiston\n *  Added eslint and export\n *  The original content is below\n */\n/*\n * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $\n *\n * Original:\n *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt\n */\n\n// if run as a web worker, respond to messages by deflating them\nvar deflate = (function () {\n\n\t/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n\t * Version: 1.0.1\n\t * LastModified: Dec 25 1999\n\t */\n\n\t/* Interface:\n\t * data = deflate(src);\n\t */\n\n\t/* constant parameters */\n\tvar zip_WSIZE = 32768;\t\t// Sliding Window size\n\tvar zip_STORED_BLOCK = 0;\n\tvar zip_STATIC_TREES = 1;\n\tvar zip_DYN_TREES = 2;\n\n\t/* for deflate */\n\tvar zip_DEFAULT_LEVEL = 6;\n\tvar zip_FULL_SEARCH = true;\n\tvar zip_INBUFSIZ = 32768;\t// Input buffer size\n\tvar zip_INBUF_EXTRA = 64;\t// Extra buffer\n\tvar zip_OUTBUFSIZ = 1024 * 8;\n\tvar zip_window_size = 2 * zip_WSIZE;\n\tvar zip_MIN_MATCH = 3;\n\tvar zip_MAX_MATCH = 258;\n\tvar zip_BITS = 16;\n\t// for SMALL_MEM\n\tvar zip_LIT_BUFSIZE = 0x2000;\n\tvar zip_HASH_BITS = 13;\n\t// for MEDIUM_MEM\n\t// var zip_LIT_BUFSIZE = 0x4000;\n\t// var zip_HASH_BITS = 14;\n\t// for BIG_MEM\n\t// var zip_LIT_BUFSIZE = 0x8000;\n\t// var zip_HASH_BITS = 15;\n\t//if(zip_LIT_BUFSIZE > zip_INBUFSIZ)\n\t//    alert(\"error: zip_INBUFSIZ is too small\");\n\t//if((zip_WSIZE<<1) > (1<<zip_BITS))\n\t//    alert(\"error: zip_WSIZE is too large\");\n\t//if(zip_HASH_BITS > zip_BITS-1)\n\t//    alert(\"error: zip_HASH_BITS is too large\");\n\t//if(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)\n\t//    alert(\"error: Code too clever\");\n\tvar zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;\n\tvar zip_HASH_SIZE = 1 << zip_HASH_BITS;\n\tvar zip_HASH_MASK = zip_HASH_SIZE - 1;\n\tvar zip_WMASK = zip_WSIZE - 1;\n\tvar zip_NIL = 0; // Tail of hash chains\n\tvar zip_TOO_FAR = 4096;\n\tvar zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;\n\tvar zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;\n\tvar zip_SMALLEST = 1;\n\tvar zip_MAX_BITS = 15;\n\tvar zip_MAX_BL_BITS = 7;\n\tvar zip_LENGTH_CODES = 29;\n\tvar zip_LITERALS = 256;\n\tvar zip_END_BLOCK = 256;\n\tvar zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;\n\tvar zip_D_CODES = 30;\n\tvar zip_BL_CODES = 19;\n\tvar zip_REP_3_6 = 16;\n\tvar zip_REPZ_3_10 = 17;\n\tvar zip_REPZ_11_138 = 18;\n\tvar zip_HEAP_SIZE = 2 * zip_L_CODES + 1;\n\tvar zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /\n\t\tzip_MIN_MATCH);\n\n\t/* variables */\n\tvar zip_free_queue;\n\tvar zip_qhead, zip_qtail;\n\tvar zip_initflag;\n\tvar zip_outbuf = null;\n\tvar zip_outcnt, zip_outoff;\n\tvar zip_complete;\n\tvar zip_window;\n\tvar zip_d_buf;\n\tvar zip_l_buf;\n\tvar zip_prev;\n\tvar zip_bi_buf;\n\tvar zip_bi_valid;\n\tvar zip_block_start;\n\tvar zip_ins_h;\n\tvar zip_hash_head;\n\tvar zip_prev_match;\n\tvar zip_match_available;\n\tvar zip_match_length;\n\tvar zip_prev_length;\n\tvar zip_strstart;\n\tvar zip_match_start;\n\tvar zip_eofile;\n\tvar zip_lookahead;\n\tvar zip_max_chain_length;\n\tvar zip_max_lazy_match;\n\tvar zip_compr_level;\n\tvar zip_good_match;\n\tvar zip_nice_match;\n\tvar zip_dyn_ltree;\n\tvar zip_dyn_dtree;\n\tvar zip_static_ltree;\n\tvar zip_static_dtree;\n\tvar zip_bl_tree;\n\tvar zip_l_desc;\n\tvar zip_d_desc;\n\tvar zip_bl_desc;\n\tvar zip_bl_count;\n\tvar zip_heap;\n\tvar zip_heap_len;\n\tvar zip_heap_max;\n\tvar zip_depth;\n\tvar zip_length_code;\n\tvar zip_dist_code;\n\tvar zip_base_length;\n\tvar zip_base_dist;\n\tvar zip_flag_buf;\n\tvar zip_last_lit;\n\tvar zip_last_dist;\n\tvar zip_last_flags;\n\tvar zip_flags;\n\tvar zip_flag_bit;\n\tvar zip_opt_len;\n\tvar zip_static_len;\n\tvar zip_deflate_data;\n\tvar zip_deflate_pos;\n\n\t/* objects (deflate) */\n\n\tfunction zip_DeflateCT() {\n\t\tthis.fc = 0; // frequency count or bit string\n\t\tthis.dl = 0; // father node in Huffman tree or length of bit string\n\t}\n\n\tfunction zip_DeflateTreeDesc() {\n\t\tthis.dyn_tree = null;\t// the dynamic tree\n\t\tthis.static_tree = null;\t// corresponding static tree or NULL\n\t\tthis.extra_bits = null;\t// extra bits for each code or NULL\n\t\tthis.extra_base = 0;\t// base index for extra_bits\n\t\tthis.elems = 0;\t\t// max number of elements in the tree\n\t\tthis.max_length = 0;\t// max bit length for the codes\n\t\tthis.max_code = 0;\t\t// largest code with non zero frequency\n\t}\n\n\t/* Values for max_lazy_match, good_match and max_chain_length, depending on\n\t * the desired pack level (0..9). The values given below have been tuned to\n\t * exclude worst case performance for pathological files. Better values may be\n\t * found for specific files.\n\t */\n\tfunction zip_DeflateConfiguration(a, b, c, d) {\n\t\tthis.good_length = a; // reduce lazy search above this match length\n\t\tthis.max_lazy = b;    // do not perform lazy search above this match length\n\t\tthis.nice_length = c; // quit search above this match length\n\t\tthis.max_chain = d;\n\t}\n\n\tfunction zip_DeflateBuffer() {\n\t\tthis.next = null;\n\t\tthis.len = 0;\n\t\tthis.ptr = new Array(zip_OUTBUFSIZ);\n\t\tthis.off = 0;\n\t}\n\n\t/* constant tables */\n\tvar zip_extra_lbits = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n\tvar zip_extra_dbits = [\n\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\tvar zip_extra_blbits = [\n\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n\tvar zip_bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\tvar zip_configuration_table = [\n\t\tnew zip_DeflateConfiguration(0, 0, 0, 0),\n\t\tnew zip_DeflateConfiguration(4, 4, 8, 4),\n\t\tnew zip_DeflateConfiguration(4, 5, 16, 8),\n\t\tnew zip_DeflateConfiguration(4, 6, 32, 32),\n\t\tnew zip_DeflateConfiguration(4, 4, 16, 16),\n\t\tnew zip_DeflateConfiguration(8, 16, 32, 32),\n\t\tnew zip_DeflateConfiguration(8, 16, 128, 128),\n\t\tnew zip_DeflateConfiguration(8, 32, 128, 256),\n\t\tnew zip_DeflateConfiguration(32, 128, 258, 1024),\n\t\tnew zip_DeflateConfiguration(32, 258, 258, 4096)];\n\n\n\t/* routines (deflate) */\n\n\tfunction zip_deflate_start(level) {\n\t\tvar i;\n\n\t\tif (!level)\n\t\t\tlevel = zip_DEFAULT_LEVEL;\n\t\telse if (level < 1)\n\t\t\tlevel = 1;\n\t\telse if (level > 9)\n\t\t\tlevel = 9;\n\n\t\tzip_compr_level = level;\n\t\tzip_initflag = false;\n\t\tzip_eofile = false;\n\t\tif (zip_outbuf != null)\n\t\t\treturn;\n\n\t\tzip_free_queue = zip_qhead = zip_qtail = null;\n\t\tzip_outbuf = new Array(zip_OUTBUFSIZ);\n\t\tzip_window = new Array(zip_window_size);\n\t\tzip_d_buf = new Array(zip_DIST_BUFSIZE);\n\t\tzip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);\n\t\tzip_prev = new Array(1 << zip_BITS);\n\t\tzip_dyn_ltree = new Array(zip_HEAP_SIZE);\n\t\tfor (i = 0; i < zip_HEAP_SIZE; i++)\n\t\t\tzip_dyn_ltree[i] = new zip_DeflateCT();\n\t\tzip_dyn_dtree = new Array(2 * zip_D_CODES + 1);\n\t\tfor (i = 0; i < 2 * zip_D_CODES + 1; i++)\n\t\t\tzip_dyn_dtree[i] = new zip_DeflateCT();\n\t\tzip_static_ltree = new Array(zip_L_CODES + 2);\n\t\tfor (i = 0; i < zip_L_CODES + 2; i++)\n\t\t\tzip_static_ltree[i] = new zip_DeflateCT();\n\t\tzip_static_dtree = new Array(zip_D_CODES);\n\t\tfor (i = 0; i < zip_D_CODES; i++)\n\t\t\tzip_static_dtree[i] = new zip_DeflateCT();\n\t\tzip_bl_tree = new Array(2 * zip_BL_CODES + 1);\n\t\tfor (i = 0; i < 2 * zip_BL_CODES + 1; i++)\n\t\t\tzip_bl_tree[i] = new zip_DeflateCT();\n\t\tzip_l_desc = new zip_DeflateTreeDesc();\n\t\tzip_d_desc = new zip_DeflateTreeDesc();\n\t\tzip_bl_desc = new zip_DeflateTreeDesc();\n\t\tzip_bl_count = new Array(zip_MAX_BITS + 1);\n\t\tzip_heap = new Array(2 * zip_L_CODES + 1);\n\t\tzip_depth = new Array(2 * zip_L_CODES + 1);\n\t\tzip_length_code = new Array(zip_MAX_MATCH - zip_MIN_MATCH + 1);\n\t\tzip_dist_code = new Array(512);\n\t\tzip_base_length = new Array(zip_LENGTH_CODES);\n\t\tzip_base_dist = new Array(zip_D_CODES);\n\t\tzip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));\n\t}\n\n\tfunction zip_deflate_end() {\n\t\tzip_free_queue = zip_qhead = zip_qtail = null;\n\t\tzip_outbuf = null;\n\t\tzip_window = null;\n\t\tzip_d_buf = null;\n\t\tzip_l_buf = null;\n\t\tzip_prev = null;\n\t\tzip_dyn_ltree = null;\n\t\tzip_dyn_dtree = null;\n\t\tzip_static_ltree = null;\n\t\tzip_static_dtree = null;\n\t\tzip_bl_tree = null;\n\t\tzip_l_desc = null;\n\t\tzip_d_desc = null;\n\t\tzip_bl_desc = null;\n\t\tzip_bl_count = null;\n\t\tzip_heap = null;\n\t\tzip_depth = null;\n\t\tzip_length_code = null;\n\t\tzip_dist_code = null;\n\t\tzip_base_length = null;\n\t\tzip_base_dist = null;\n\t\tzip_flag_buf = null;\n\t}\n\n\tfunction zip_reuse_queue(p) {\n\t\tp.next = zip_free_queue;\n\t\tzip_free_queue = p;\n\t}\n\n\tfunction zip_new_queue() {\n\t\tvar p;\n\n\t\tif (zip_free_queue != null) {\n\t\t\tp = zip_free_queue;\n\t\t\tzip_free_queue = zip_free_queue.next;\n\t\t}\n\t\telse\n\t\t\tp = new zip_DeflateBuffer();\n\t\tp.next = null;\n\t\tp.len = p.off = 0;\n\n\t\treturn p;\n\t}\n\n\tfunction zip_head1(i) {\n\t\treturn zip_prev[zip_WSIZE + i];\n\t}\n\n\tfunction zip_head2(i, val) {\n\t\treturn zip_prev[zip_WSIZE + i] = val;\n\t}\n\n\t/* put_byte is used for the compressed output, put_ubyte for the\n\t * uncompressed output. However unlzw() uses window for its\n\t * suffix table instead of its output buffer, so it does not use put_ubyte\n\t * (to be cleaned up).\n\t */\n\tfunction zip_put_byte(c) {\n\t\tzip_outbuf[zip_outoff + zip_outcnt++] = c;\n\t\tif (zip_outoff + zip_outcnt == zip_OUTBUFSIZ)\n\t\t\tzip_qoutbuf();\n\t}\n\n\t/* Output a 16 bit value, lsb first */\n\tfunction zip_put_short(w) {\n\t\tw &= 0xffff;\n\t\tif (zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {\n\t\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);\n\t\t\tzip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);\n\t\t} else {\n\t\t\tzip_put_byte(w & 0xff);\n\t\t\tzip_put_byte(w >>> 8);\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Insert string s in the dictionary and set match_head to the previous head\n\t * of the hash chain (the most recent string with same hash key). Return\n\t * the previous length of the hash chain.\n\t * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n\t *    input characters and the first MIN_MATCH bytes of s are valid\n\t *    (except for the last MIN_MATCH-1 bytes of the input file).\n\t */\n\tfunction zip_INSERT_STRING() {\n\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT)\n\t\t\t^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))\n\t\t\t& zip_HASH_MASK;\n\t\tzip_hash_head = zip_head1(zip_ins_h);\n\t\tzip_prev[zip_strstart & zip_WMASK] = zip_hash_head;\n\t\tzip_head2(zip_ins_h, zip_strstart);\n\t}\n\n\t/* Send a code of the given tree. c and tree must not have side effects */\n\tfunction zip_SEND_CODE(c, tree) {\n\t\tzip_send_bits(tree[c].fc, tree[c].dl);\n\t}\n\n\t/* Mapping from a distance to a distance code. dist is the distance - 1 and\n\t * must not have side effects. dist_code[256] and dist_code[257] are never\n\t * used.\n\t */\n\tfunction zip_D_CODE(dist) {\n\t\treturn (dist < 256 ? zip_dist_code[dist]\n\t\t\t: zip_dist_code[256 + (dist >> 7)]) & 0xff;\n\t}\n\n\t/* ==========================================================================\n\t * Compares to subtrees, using the tree depth as tie breaker when\n\t * the subtrees have equal frequency. This minimizes the worst case length.\n\t */\n\tfunction zip_SMALLER(tree, n, m) {\n\t\treturn tree[n].fc < tree[m].fc ||\n\t\t\t(tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);\n\t}\n\n\t/* ==========================================================================\n\t * read string data\n\t */\n\tfunction zip_read_buff(buff, offset, n) {\n\t\tvar i;\n\t\tfor (i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)\n\t\t\tbuff[offset + i] =\n\t\t\t\tzip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;\n\t\treturn i;\n\t}\n\n\t/* ==========================================================================\n\t * Initialize the \"longest match\" routines for a new file\n\t */\n\tfunction zip_lm_init() {\n\t\tvar j;\n\n\t\t/* Initialize the hash table. */\n\t\tfor (j = 0; j < zip_HASH_SIZE; j++)\n\t\t\t//\tzip_head2(j, zip_NIL);\n\t\t\tzip_prev[zip_WSIZE + j] = 0;\n\t\t/* prev will be initialized on the fly */\n\n    /* Set the default configuration parameters:\n     */\n\t\tzip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;\n\t\tzip_good_match = zip_configuration_table[zip_compr_level].good_length;\n\t\tif (!zip_FULL_SEARCH)\n\t\t\tzip_nice_match = zip_configuration_table[zip_compr_level].nice_length;\n\t\tzip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;\n\n\t\tzip_strstart = 0;\n\t\tzip_block_start = 0;\n\n\t\tzip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);\n\t\tif (zip_lookahead <= 0) {\n\t\t\tzip_eofile = true;\n\t\t\tzip_lookahead = 0;\n\t\t\treturn;\n\t\t}\n\t\tzip_eofile = false;\n    /* Make sure that we always have enough lookahead. This is important\n     * if input comes from a device such as a tty.\n     */\n\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\t\tzip_fill_window();\n\n    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is\n     * not important since only literal bytes will be emitted.\n     */\n\t\tzip_ins_h = 0;\n\t\tfor (j = 0; j < zip_MIN_MATCH - 1; j++) {\n\t\t\t//      UPDATE_HASH(ins_h, window[j]);\n\t\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Set match_start to the longest match starting at the given string and\n\t * return its length. Matches shorter or equal to prev_length are discarded,\n\t * in which case the result is equal to prev_length and match_start is\n\t * garbage.\n\t * IN assertions: cur_match is the head of the hash chain for the current\n\t *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n\t */\n\tfunction zip_longest_match(cur_match) {\n\t\tvar chain_length = zip_max_chain_length; // max hash chain length\n\t\tvar scanp = zip_strstart; // current string\n\t\tvar matchp;\t\t// matched string\n\t\tvar len;\t\t// length of current match\n\t\tvar best_len = zip_prev_length;\t// best match length so far\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\t\tvar limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);\n\n\t\tvar strendp = zip_strstart + zip_MAX_MATCH;\n\t\tvar scan_end1 = zip_window[scanp + best_len - 1];\n\t\tvar scan_end = zip_window[scanp + best_len];\n\n\t\t/* Do not waste too much time if we already have a good match: */\n\t\tif (zip_prev_length >= zip_good_match)\n\t\t\tchain_length >>= 2;\n\n\t\t//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n\t\tdo {\n\t\t\t//    Assert(cur_match < encoder->strstart, \"no future\");\n\t\t\tmatchp = cur_match;\n\n\t\t\t/* Skip to next match if the match length cannot increase\n\t\t\t\t\t* or if the match length is less than 2:\n\t\t\t*/\n\t\t\tif (zip_window[matchp + best_len] != scan_end ||\n\t\t\t\tzip_window[matchp + best_len - 1] != scan_end1 ||\n\t\t\t\tzip_window[matchp] != zip_window[scanp] ||\n\t\t\t\tzip_window[++matchp] != zip_window[scanp + 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* The check at best_len-1 can be removed because it will be made\n\t\t\t\t\t\t * again later. (This heuristic is not always a win.)\n\t\t\t\t\t\t * It is not necessary to compare scan[2] and match[2] since they\n\t\t\t\t\t\t * are always equal when the other bytes match, given that\n\t\t\t\t\t\t * the hash keys are equal and that HASH_BITS >= 8.\n\t\t\t\t\t\t */\n\t\t\tscanp += 2;\n\t\t\tmatchp++;\n\n\t\t\t/* We check for insufficient lookahead only every 8th comparison;\n\t\t\t\t\t\t * the 256th check will be made at strstart+258.\n\t\t\t\t\t\t */\n\t\t\tdo {\n\t\t\t} while (zip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\tzip_window[++scanp] == zip_window[++matchp] &&\n\t\t\t\tscanp < strendp);\n\n\t\t\tlen = zip_MAX_MATCH - (strendp - scanp);\n\t\t\tscanp = strendp - zip_MAX_MATCH;\n\n\t\t\tif (len > best_len) {\n\t\t\t\tzip_match_start = cur_match;\n\t\t\t\tbest_len = len;\n\t\t\t\tif (zip_FULL_SEARCH) {\n\t\t\t\t\tif (len >= zip_MAX_MATCH) break;\n\t\t\t\t} else {\n\t\t\t\t\tif (len >= zip_nice_match) break;\n\t\t\t\t}\n\n\t\t\t\tscan_end1 = zip_window[scanp + best_len - 1];\n\t\t\t\tscan_end = zip_window[scanp + best_len];\n\t\t\t}\n\t\t} while ((cur_match = zip_prev[cur_match & zip_WMASK]) > limit\n\t\t\t&& --chain_length != 0);\n\n\t\treturn best_len;\n\t}\n\n\t/* ==========================================================================\n\t * Fill the window when the lookahead becomes insufficient.\n\t * Updates strstart and lookahead, and sets eofile if end of input file.\n\t * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n\t * OUT assertions: at least one byte has been read, or eofile is set;\n\t *    file reads are performed for at least two bytes (required for the\n\t *    translate_eol option).\n\t */\n\tfunction zip_fill_window() {\n\t\tvar n, m;\n\n\t\t// Amount of free space at the end of the window.\n\t\tvar more = zip_window_size - zip_lookahead - zip_strstart;\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n\t\tif (more == -1) {\n\t\t\t/* Very unlikely, but possible on 16 bit machine if strstart == 0\n\t\t\t\t\t\t * and lookahead == 1 (input done one byte at time)\n\t\t\t\t\t\t */\n\t\t\tmore--;\n\t\t} else if (zip_strstart >= zip_WSIZE + zip_MAX_DIST) {\n\t\t\t/* By the IN assertion, the window is not empty so we can't confuse\n\t\t\t\t\t\t * more == 0 with more == 64K on a 16 bit machine.\n\t\t\t\t\t\t */\n\t\t\t//\tAssert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n\t\t\t//\tSystem.arraycopy(window, WSIZE, window, 0, WSIZE);\n\t\t\tfor (n = 0; n < zip_WSIZE; n++)\n\t\t\t\tzip_window[n] = zip_window[n + zip_WSIZE];\n\n\t\t\tzip_match_start -= zip_WSIZE;\n\t\t\tzip_strstart -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */\n\t\t\tzip_block_start -= zip_WSIZE;\n\n\t\t\tfor (n = 0; n < zip_HASH_SIZE; n++) {\n\t\t\t\tm = zip_head1(n);\n\t\t\t\tzip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t\t\t}\n\t\t\tfor (n = 0; n < zip_WSIZE; n++) {\n\t\t\t\t/* If n is not on any hash chain, prev[n] is garbage but\n\t\t\t\t * its value will never be used.\n\t\t\t\t */\n\t\t\t\tm = zip_prev[n];\n\t\t\t\tzip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);\n\t\t\t}\n\t\t\tmore += zip_WSIZE;\n\t\t}\n\t\t// At this point, more >= 2\n\t\tif (!zip_eofile) {\n\t\t\tn = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);\n\t\t\tif (n <= 0)\n\t\t\t\tzip_eofile = true;\n\t\t\telse\n\t\t\t\tzip_lookahead += n;\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Processes a new input file and return its compressed length. This\n\t * function does not perform lazy evaluationof matches and inserts\n\t * new strings in the dictionary only for unmatched strings or for short\n\t * matches. It is used only for the fast compression options.\n\t */\n\tfunction zip_deflate_fast() {\n\t\twhile (zip_lookahead != 0 && zip_qhead == null) {\n\t\t\tvar flush; // set if current block must be flushed\n\n\t\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t\t */\n\t\t\tzip_INSERT_STRING();\n\n\t\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t\t * At this point we have always match_length < MIN_MATCH\n\t\t\t */\n\t\t\tif (zip_hash_head != zip_NIL &&\n\t\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t\t\t\t/* To simplify the code, we prevent matches with the string\n\t\t\t\t * of window index 0 (in particular we have to avoid a match\n\t\t\t\t * of the string with itself at the start of the input file).\n\t\t\t\t */\n\t\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\n\t\t\t\t/* longest_match() sets match_start */\n\t\t\t\tif (zip_match_length > zip_lookahead)\n\t\t\t\t\tzip_match_length = zip_lookahead;\n\t\t\t}\n\t\t\tif (zip_match_length >= zip_MIN_MATCH) {\n\t\t\t\t//\t    check_match(strstart, match_start, match_length);\n\n\t\t\t\tflush = zip_ct_tally(zip_strstart - zip_match_start,\n\t\t\t\t\tzip_match_length - zip_MIN_MATCH);\n\t\t\t\tzip_lookahead -= zip_match_length;\n\n\t\t\t\t/* Insert new strings in the hash table only if the match length\n\t\t\t\t * is not too large. This saves time but degrades compression.\n\t\t\t\t */\n\t\t\t\tif (zip_match_length <= zip_max_lazy_match) {\n\t\t\t\t\tzip_match_length--; // string at strstart already in hash table\n\t\t\t\t\tdo {\n\t\t\t\t\t\tzip_strstart++;\n\t\t\t\t\t\tzip_INSERT_STRING();\n\t\t\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t\t\t * these bytes are garbage, but it does not matter since\n\t\t\t\t\t\t * the next lookahead bytes will be emitted as literals.\n\t\t\t\t\t\t */\n\t\t\t\t\t} while (--zip_match_length != 0);\n\t\t\t\t\tzip_strstart++;\n\t\t\t\t} else {\n\t\t\t\t\tzip_strstart += zip_match_length;\n\t\t\t\t\tzip_match_length = 0;\n\t\t\t\t\tzip_ins_h = zip_window[zip_strstart] & 0xff;\n\t\t\t\t\t//\t\tUPDATE_HASH(ins_h, window[strstart + 1]);\n\t\t\t\t\tzip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;\n\n\t\t\t\t\t//#if MIN_MATCH != 3\n\t\t\t\t\t//\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n\t\t\t\t\t//#endif\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* No match, output a literal byte */\n\t\t\t\tflush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);\n\t\t\t\tzip_lookahead--;\n\t\t\t\tzip_strstart++;\n\t\t\t}\n\t\t\tif (flush) {\n\t\t\t\tzip_flush_block(0);\n\t\t\t\tzip_block_start = zip_strstart;\n\t\t\t}\n\n\t\t\t/* Make sure that we always have enough lookahead, except\n\t\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t * string following the next match.\n\t\t\t */\n\t\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\t\t\tzip_fill_window();\n\t\t}\n\t}\n\n\tfunction zip_deflate_better() {\n\t\t/* Process the input block. */\n\t\twhile (zip_lookahead != 0 && zip_qhead == null) {\n\t\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t\t */\n\t\t\tzip_INSERT_STRING();\n\n\t\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t\t */\n\t\t\tzip_prev_length = zip_match_length;\n\t\t\tzip_prev_match = zip_match_start;\n\t\t\tzip_match_length = zip_MIN_MATCH - 1;\n\n\t\t\tif (zip_hash_head != zip_NIL &&\n\t\t\t\tzip_prev_length < zip_max_lazy_match &&\n\t\t\t\tzip_strstart - zip_hash_head <= zip_MAX_DIST) {\n\t\t\t\t/* To simplify the code, we prevent matches with the string\n\t\t\t\t * of window index 0 (in particular we have to avoid a match\n\t\t\t\t * of the string with itself at the start of the input file).\n\t\t\t\t */\n\t\t\t\tzip_match_length = zip_longest_match(zip_hash_head);\n\t\t\t\t/* longest_match() sets match_start */\n\t\t\t\tif (zip_match_length > zip_lookahead)\n\t\t\t\t\tzip_match_length = zip_lookahead;\n\n\t\t\t\t/* Ignore a length 3 match if it is too distant: */\n\t\t\t\tif (zip_match_length == zip_MIN_MATCH &&\n\t\t\t\t\tzip_strstart - zip_match_start > zip_TOO_FAR) {\n\t\t\t\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t\t\t * but we will ignore the current match anyway.\n\t\t\t\t\t */\n\t\t\t\t\tzip_match_length--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* If there was a match at the previous step and the current\n\t\t\t * match is not better, output the previous match:\n\t\t\t */\n\t\t\tif (zip_prev_length >= zip_MIN_MATCH &&\n\t\t\t\tzip_match_length <= zip_prev_length) {\n\t\t\t\tvar flush; // set if current block must be flushed\n\n\t\t\t\t//\t    check_match(strstart - 1, prev_match, prev_length);\n\t\t\t\tflush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,\n\t\t\t\t\tzip_prev_length - zip_MIN_MATCH);\n\n\t\t\t\t/* Insert in hash table all strings up to the end of the match.\n\t\t\t\t * strstart-1 and strstart are already inserted.\n\t\t\t\t */\n\t\t\t\tzip_lookahead -= zip_prev_length - 1;\n\t\t\t\tzip_prev_length -= 2;\n\t\t\t\tdo {\n\t\t\t\t\tzip_strstart++;\n\t\t\t\t\tzip_INSERT_STRING();\n\t\t\t\t\t/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t\t\t * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n\t\t\t\t\t * these bytes are garbage, but it does not matter since the\n\t\t\t\t\t * next lookahead bytes will always be emitted as literals.\n\t\t\t\t\t */\n\t\t\t\t} while (--zip_prev_length != 0);\n\t\t\t\tzip_match_available = 0;\n\t\t\t\tzip_match_length = zip_MIN_MATCH - 1;\n\t\t\t\tzip_strstart++;\n\t\t\t\tif (flush) {\n\t\t\t\t\tzip_flush_block(0);\n\t\t\t\t\tzip_block_start = zip_strstart;\n\t\t\t\t}\n\t\t\t} else if (zip_match_available != 0) {\n\t\t\t\t/* If there was no match at the previous position, output a\n\t\t\t\t * single literal. If there was a match but the current match\n\t\t\t\t * is longer, truncate the previous match to a single literal.\n\t\t\t\t */\n\t\t\t\tif (zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {\n\t\t\t\t\tzip_flush_block(0);\n\t\t\t\t\tzip_block_start = zip_strstart;\n\t\t\t\t}\n\t\t\t\tzip_strstart++;\n\t\t\t\tzip_lookahead--;\n\t\t\t} else {\n\t\t\t\t/* There is no previous match to compare with, wait for\n\t\t\t\t * the next step to decide.\n\t\t\t\t */\n\t\t\t\tzip_match_available = 1;\n\t\t\t\tzip_strstart++;\n\t\t\t\tzip_lookahead--;\n\t\t\t}\n\n\t\t\t/* Make sure that we always have enough lookahead, except\n\t\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t\t * string following the next match.\n\t\t\t */\n\t\t\twhile (zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)\n\t\t\t\tzip_fill_window();\n\t\t}\n\t}\n\n\tfunction zip_init_deflate() {\n\t\tif (zip_eofile)\n\t\t\treturn;\n\t\tzip_bi_buf = 0;\n\t\tzip_bi_valid = 0;\n\t\tzip_ct_init();\n\t\tzip_lm_init();\n\n\t\tzip_qhead = null;\n\t\tzip_outcnt = 0;\n\t\tzip_outoff = 0;\n\n\t\tif (zip_compr_level <= 3) {\n\t\t\tzip_prev_length = zip_MIN_MATCH - 1;\n\t\t\tzip_match_length = 0;\n\t\t}\n\t\telse {\n\t\t\tzip_match_length = zip_MIN_MATCH - 1;\n\t\t\tzip_match_available = 0;\n\t\t}\n\n\t\tzip_complete = false;\n\t}\n\n\t/* ==========================================================================\n\t * Same as above, but achieves better compression. We use a lazy\n\t * evaluation for matches: a match is finally adopted only if there is\n\t * no better match at the next window position.\n\t */\n\tfunction zip_deflate_internal(buff, off, buff_size) {\n\t\tvar n;\n\n\t\tif (!zip_initflag) {\n\t\t\tzip_init_deflate();\n\t\t\tzip_initflag = true;\n\t\t\tif (zip_lookahead == 0) { // empty\n\t\t\t\tzip_complete = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tif ((n = zip_qcopy(buff, off, buff_size)) == buff_size)\n\t\t\treturn buff_size;\n\n\t\tif (zip_complete)\n\t\t\treturn n;\n\n\t\tif (zip_compr_level <= 3) // optimized for speed\n\t\t\tzip_deflate_fast();\n\t\telse\n\t\t\tzip_deflate_better();\n\t\tif (zip_lookahead == 0) {\n\t\t\tif (zip_match_available != 0)\n\t\t\t\tzip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);\n\t\t\tzip_flush_block(1);\n\t\t\tzip_complete = true;\n\t\t}\n\t\treturn n + zip_qcopy(buff, n + off, buff_size - n);\n\t}\n\n\tfunction zip_qcopy(buff, off, buff_size) {\n\t\tvar n, i, j;\n\n\t\tn = 0;\n\t\twhile (zip_qhead != null && n < buff_size) {\n\t\t\ti = buff_size - n;\n\t\t\tif (i > zip_qhead.len)\n\t\t\t\ti = zip_qhead.len;\n\t\t\t//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbuff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];\n\n\t\t\tzip_qhead.off += i;\n\t\t\tzip_qhead.len -= i;\n\t\t\tn += i;\n\t\t\tif (zip_qhead.len == 0) {\n\t\t\t\tvar p;\n\t\t\t\tp = zip_qhead;\n\t\t\t\tzip_qhead = zip_qhead.next;\n\t\t\t\tzip_reuse_queue(p);\n\t\t\t}\n\t\t}\n\n\t\tif (n == buff_size)\n\t\t\treturn n;\n\n\t\tif (zip_outoff < zip_outcnt) {\n\t\t\ti = buff_size - n;\n\t\t\tif (i > zip_outcnt - zip_outoff)\n\t\t\t\ti = zip_outcnt - zip_outoff;\n\t\t\t// System.arraycopy(outbuf, outoff, buff, off + n, i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbuff[off + n + j] = zip_outbuf[zip_outoff + j];\n\t\t\tzip_outoff += i;\n\t\t\tn += i;\n\t\t\tif (zip_outcnt == zip_outoff)\n\t\t\t\tzip_outcnt = zip_outoff = 0;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/* ==========================================================================\n\t * Allocate the match buffer, initialize the various tables and save the\n\t * location of the internal file attribute (ascii/binary) and method\n\t * (DEFLATE/STORE).\n\t */\n\tfunction zip_ct_init() {\n\t\tvar n;\t// iterates over tree elements\n\t\tvar bits;\t// bit counter\n\t\tvar length;\t// length value\n\t\tvar code;\t// code value\n\t\tvar dist;\t// distance index\n\n\t\tif (zip_static_dtree[0].dl != 0) return; // ct_init already called\n\n\t\tzip_l_desc.dyn_tree = zip_dyn_ltree;\n\t\tzip_l_desc.static_tree = zip_static_ltree;\n\t\tzip_l_desc.extra_bits = zip_extra_lbits;\n\t\tzip_l_desc.extra_base = zip_LITERALS + 1;\n\t\tzip_l_desc.elems = zip_L_CODES;\n\t\tzip_l_desc.max_length = zip_MAX_BITS;\n\t\tzip_l_desc.max_code = 0;\n\n\t\tzip_d_desc.dyn_tree = zip_dyn_dtree;\n\t\tzip_d_desc.static_tree = zip_static_dtree;\n\t\tzip_d_desc.extra_bits = zip_extra_dbits;\n\t\tzip_d_desc.extra_base = 0;\n\t\tzip_d_desc.elems = zip_D_CODES;\n\t\tzip_d_desc.max_length = zip_MAX_BITS;\n\t\tzip_d_desc.max_code = 0;\n\n\t\tzip_bl_desc.dyn_tree = zip_bl_tree;\n\t\tzip_bl_desc.static_tree = null;\n\t\tzip_bl_desc.extra_bits = zip_extra_blbits;\n\t\tzip_bl_desc.extra_base = 0;\n\t\tzip_bl_desc.elems = zip_BL_CODES;\n\t\tzip_bl_desc.max_length = zip_MAX_BL_BITS;\n\t\tzip_bl_desc.max_code = 0;\n\n\t\t// Initialize the mapping length (0..255) -> length code (0..28)\n\t\tlength = 0;\n\t\tfor (code = 0; code < zip_LENGTH_CODES - 1; code++) {\n\t\t\tzip_base_length[code] = length;\n\t\t\tfor (n = 0; n < (1 << zip_extra_lbits[code]); n++)\n\t\t\t\tzip_length_code[length++] = code;\n\t\t}\n\t\t// Assert (length == 256, \"ct_init: length != 256\");\n\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n\t\tzip_length_code[length - 1] = code;\n\n\t\t/* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\t\tdist = 0;\n\t\tfor (code = 0; code < 16; code++) {\n\t\t\tzip_base_dist[code] = dist;\n\t\t\tfor (n = 0; n < (1 << zip_extra_dbits[code]); n++) {\n\t\t\t\tzip_dist_code[dist++] = code;\n\t\t\t}\n\t\t}\n\t\t// Assert (dist == 256, \"ct_init: dist != 256\");\n\t\tdist >>= 7; // from now on, all distances are divided by 128\n\t\tfor (; code < zip_D_CODES; code++) {\n\t\t\tzip_base_dist[code] = dist << 7;\n\t\t\tfor (n = 0; n < (1 << (zip_extra_dbits[code] - 7)); n++)\n\t\t\t\tzip_dist_code[256 + dist++] = code;\n\t\t}\n\t\t// Assert (dist == 256, \"ct_init: 256+dist != 512\");\n\n\t\t// Construct the codes of the static literal tree\n\t\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\n\t\t\tzip_bl_count[bits] = 0;\n\t\tn = 0;\n\t\twhile (n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n\t\twhile (n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }\n\t\twhile (n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }\n\t\twhile (n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n\t\tzip_gen_codes(zip_static_ltree, zip_L_CODES + 1);\n\n\t\t/* The static distance tree is trivial: */\n\t\tfor (n = 0; n < zip_D_CODES; n++) {\n\t\t\tzip_static_dtree[n].dl = 5;\n\t\t\tzip_static_dtree[n].fc = zip_bi_reverse(n, 5);\n\t\t}\n\n\t\t// Initialize the first block of the first file:\n\t\tzip_init_block();\n\t}\n\n\t/* ==========================================================================\n\t * Initialize a new block.\n\t */\n\tfunction zip_init_block() {\n\t\tvar n; // iterates over tree elements\n\n\t\t// Initialize the trees.\n\t\tfor (n = 0; n < zip_L_CODES; n++) zip_dyn_ltree[n].fc = 0;\n\t\tfor (n = 0; n < zip_D_CODES; n++) zip_dyn_dtree[n].fc = 0;\n\t\tfor (n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;\n\n\t\tzip_dyn_ltree[zip_END_BLOCK].fc = 1;\n\t\tzip_opt_len = zip_static_len = 0;\n\t\tzip_last_lit = zip_last_dist = zip_last_flags = 0;\n\t\tzip_flags = 0;\n\t\tzip_flag_bit = 1;\n\t}\n\n\t/* ==========================================================================\n\t * Restore the heap property by moving down the tree starting at node k,\n\t * exchanging a node with the smallest of its two sons if necessary, stopping\n\t * when the heap property is re-established (each father smaller than its\n\t * two sons).\n\t */\n\tfunction zip_pqdownheap(\n\t\ttree,\t// the tree to restore\n\t\tk) {\t// node to move down\n\t\tvar v = zip_heap[k];\n\t\tvar j = k << 1;\t// left son of k\n\n\t\twhile (j <= zip_heap_len) {\n\t\t\t// Set j to the smallest of the two sons:\n\t\t\tif (j < zip_heap_len &&\n\t\t\t\tzip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))\n\t\t\t\tj++;\n\n\t\t\t// Exit if v is smaller than both sons\n\t\t\tif (zip_SMALLER(tree, v, zip_heap[j]))\n\t\t\t\tbreak;\n\n\t\t\t// Exchange v with the smallest son\n\t\t\tzip_heap[k] = zip_heap[j];\n\t\t\tk = j;\n\n\t\t\t// And continue down the tree, setting j to the left son of k\n\t\t\tj <<= 1;\n\t\t}\n\t\tzip_heap[k] = v;\n\t}\n\n\t/* ==========================================================================\n\t * Compute the optimal bit lengths for a tree and update the total bit length\n\t * for the current block.\n\t * IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t *    above are the tree nodes sorted by increasing frequency.\n\t * OUT assertions: the field len is set to the optimal bit length, the\n\t *     array bl_count contains the frequencies for each bit length.\n\t *     The length opt_len is updated; static_len is also updated if stree is\n\t *     not null.\n\t */\n\tfunction zip_gen_bitlen(desc) { // the tree descriptor\n\t\tvar tree = desc.dyn_tree;\n\t\tvar extra = desc.extra_bits;\n\t\tvar base = desc.extra_base;\n\t\tvar max_code = desc.max_code;\n\t\tvar max_length = desc.max_length;\n\t\tvar stree = desc.static_tree;\n\t\tvar h;\t\t// heap index\n\t\tvar n, m;\t\t// iterate over the tree elements\n\t\tvar bits;\t\t// bit length\n\t\tvar xbits;\t\t// extra bits\n\t\tvar f;\t\t// frequency\n\t\tvar overflow = 0;\t// number of elements with bit length too large\n\n\t\tfor (bits = 0; bits <= zip_MAX_BITS; bits++)\n\t\t\tzip_bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n\t\ttree[zip_heap[zip_heap_max]].dl = 0; // root of the heap\n\n\t\tfor (h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {\n\t\t\tn = zip_heap[h];\n\t\t\tbits = tree[tree[n].dl].dl + 1;\n\t\t\tif (bits > max_length) {\n\t\t\t\tbits = max_length;\n\t\t\t\toverflow++;\n\t\t\t}\n\t\t\ttree[n].dl = bits;\n\t\t\t// We overwrite tree[n].dl which is no longer needed\n\n\t\t\tif (n > max_code)\n\t\t\t\tcontinue; // not a leaf node\n\n\t\t\tzip_bl_count[bits]++;\n\t\t\txbits = 0;\n\t\t\tif (n >= base)\n\t\t\t\txbits = extra[n - base];\n\t\t\tf = tree[n].fc;\n\t\t\tzip_opt_len += f * (bits + xbits);\n\t\t\tif (stree != null)\n\t\t\t\tzip_static_len += f * (stree[n].dl + xbits);\n\t\t}\n\t\tif (overflow == 0)\n\t\t\treturn;\n\n\t\t// This happens for example on obj2 and pic of the Calgary corpus\n\n\t\t// Find the first bit length which could increase:\n\t\tdo {\n\t\t\tbits = max_length - 1;\n\t\t\twhile (zip_bl_count[bits] == 0)\n\t\t\t\tbits--;\n\t\t\tzip_bl_count[bits]--;\t\t// move one leaf down the tree\n\t\t\tzip_bl_count[bits + 1] += 2;\t// move one overflow item as its brother\n\t\t\tzip_bl_count[max_length]--;\n\t\t\t/* The brother of the overflow item also moves one step up,\n\t\t\t * but this does not affect bl_count[max_length]\n\t\t\t */\n\t\t\toverflow -= 2;\n\t\t} while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n\t\tfor (bits = max_length; bits != 0; bits--) {\n\t\t\tn = zip_bl_count[bits];\n\t\t\twhile (n != 0) {\n\t\t\t\tm = zip_heap[--h];\n\t\t\t\tif (m > max_code)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tree[m].dl != bits) {\n\t\t\t\t\tzip_opt_len += (bits - tree[m].dl) * tree[m].fc;\n\t\t\t\t\ttree[m].fc = bits;\n\t\t\t\t}\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\t}\n\n  /* ==========================================================================\n   * Generate the codes for a given tree and bit counts (which need not be\n   * optimal).\n   * IN assertion: the array bl_count contains the bit length statistics for\n   * the given tree and the field len is set for all tree elements.\n   * OUT assertion: the field code is set for all tree elements of non\n   *     zero code length.\n   */\n\tfunction zip_gen_codes(tree,\t// the tree to decorate\n\t\tmax_code) {\t// largest code with non zero frequency\n\t\tvar next_code = new Array(zip_MAX_BITS + 1); // next code value for each bit length\n\t\tvar code = 0;\t\t// running code value\n\t\tvar bits;\t\t\t// bit index\n\t\tvar n;\t\t\t// code index\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n\t\tfor (bits = 1; bits <= zip_MAX_BITS; bits++) {\n\t\t\tcode = ((code + zip_bl_count[bits - 1]) << 1);\n\t\t\tnext_code[bits] = code;\n\t\t}\n\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n\t\t//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t\t//\t    \"inconsistent bit counts\");\n\t\t//    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tvar len = tree[n].dl;\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\t// Now reverse the bits\n\t\t\ttree[n].fc = zip_bi_reverse(next_code[len]++, len);\n\n\t\t\t//      Tracec(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n\t\t\t//\t  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Construct one Huffman tree and assigns the code bit strings and lengths.\n\t * Update the total bit length for the current block.\n\t * IN assertion: the field freq is set for all tree elements.\n\t * OUT assertions: the fields len and code are set to the optimal bit length\n\t *     and corresponding code. The length opt_len is updated; static_len is\n\t *     also updated if stree is not null. The field max_code is set.\n\t */\n\tfunction zip_build_tree(desc) { // the tree descriptor\n\t\tvar tree = desc.dyn_tree;\n\t\tvar stree = desc.static_tree;\n\t\tvar elems = desc.elems;\n\t\tvar n, m;\t\t// iterate over heap elements\n\t\tvar max_code = -1;\t// largest code with non zero frequency\n\t\tvar node = elems;\t// next internal node of the tree\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n\t\tzip_heap_len = 0;\n\t\tzip_heap_max = zip_HEAP_SIZE;\n\n\t\tfor (n = 0; n < elems; n++) {\n\t\t\tif (tree[n].fc != 0) {\n\t\t\t\tzip_heap[++zip_heap_len] = max_code = n;\n\t\t\t\tzip_depth[n] = 0;\n\t\t\t} else\n\t\t\t\ttree[n].dl = 0;\n\t\t}\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n\t\twhile (zip_heap_len < 2) {\n\t\t\tvar xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);\n\t\t\ttree[xnew].fc = 1;\n\t\t\tzip_depth[xnew] = 0;\n\t\t\tzip_opt_len--;\n\t\t\tif (stree != null)\n\t\t\t\tzip_static_len -= stree[xnew].dl;\n\t\t\t// new is 0 or 1 so it does not have extra bits\n\t\t}\n\t\tdesc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n\t\tfor (n = zip_heap_len >> 1; n >= 1; n--)\n\t\t\tzip_pqdownheap(tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n\t\tdo {\n\t\t\tn = zip_heap[zip_SMALLEST];\n\t\t\tzip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];\n\t\t\tzip_pqdownheap(tree, zip_SMALLEST);\n\n\t\t\tm = zip_heap[zip_SMALLEST];  // m = node of next least frequency\n\n\t\t\t// keep the nodes sorted by frequency\n\t\t\tzip_heap[--zip_heap_max] = n;\n\t\t\tzip_heap[--zip_heap_max] = m;\n\n\t\t\t// Create a new node father of n and m\n\t\t\ttree[node].fc = tree[n].fc + tree[m].fc;\n\t\t\t//\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n\t\t\tif (zip_depth[n] > zip_depth[m] + 1)\n\t\t\t\tzip_depth[node] = zip_depth[n];\n\t\t\telse\n\t\t\t\tzip_depth[node] = zip_depth[m] + 1;\n\t\t\ttree[n].dl = tree[m].dl = node;\n\n\t\t\t// and insert the new node in the heap\n\t\t\tzip_heap[zip_SMALLEST] = node++;\n\t\t\tzip_pqdownheap(tree, zip_SMALLEST);\n\n\t\t} while (zip_heap_len >= 2);\n\n\t\tzip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n\t\tzip_gen_bitlen(desc);\n\n\t\t// The field len is now set, we can generate the bit codes\n\t\tzip_gen_codes(tree, max_code);\n\t}\n\n\t/* ==========================================================================\n\t * Scan a literal or distance tree to determine the frequencies of the codes\n\t * in the bit length tree. Updates opt_len to take into account the repeat\n\t * counts. (The contribution of the bit length codes will be added later\n\t * during the construction of bl_tree.)\n\t */\n\tfunction zip_scan_tree(tree,// the tree to be scanned\n\t\tmax_code) {  // and its largest code of non zero frequency\n\t\tvar n;\t\t\t// iterates over all tree elements\n\t\tvar prevlen = -1;\t\t// last emitted length\n\t\tvar curlen;\t\t\t// length of current code\n\t\tvar nextlen = tree[0].dl;\t// length of next code\n\t\tvar count = 0;\t\t// repeat count of the current code\n\t\tvar max_count = 7;\t\t// max repeat count\n\t\tvar min_count = 4;\t\t// min repeat count\n\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t}\n\t\ttree[max_code + 1].dl = 0xffff; // guard\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tcurlen = nextlen;\n\t\t\tnextlen = tree[n + 1].dl;\n\t\t\tif (++count < max_count && curlen == nextlen)\n\t\t\t\tcontinue;\n\t\t\telse if (count < min_count)\n\t\t\t\tzip_bl_tree[curlen].fc += count;\n\t\t\telse if (curlen != 0) {\n\t\t\t\tif (curlen != prevlen)\n\t\t\t\t\tzip_bl_tree[curlen].fc++;\n\t\t\t\tzip_bl_tree[zip_REP_3_6].fc++;\n\t\t\t} else if (count <= 10)\n\t\t\t\tzip_bl_tree[zip_REPZ_3_10].fc++;\n\t\t\telse\n\t\t\t\tzip_bl_tree[zip_REPZ_11_138].fc++;\n\t\t\tcount = 0; prevlen = curlen;\n\t\t\tif (nextlen == 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t} else if (curlen == nextlen) {\n\t\t\t\tmax_count = 6;\n\t\t\t\tmin_count = 3;\n\t\t\t} else {\n\t\t\t\tmax_count = 7;\n\t\t\t\tmin_count = 4;\n\t\t\t}\n\t\t}\n\t}\n\n  /* ==========================================================================\n   * Send a literal or distance tree in compressed form, using the codes in\n   * bl_tree.\n   */\n\tfunction zip_send_tree(tree, // the tree to be scanned\n\t\tmax_code) { // and its largest code of non zero frequency\n\t\tvar n;\t\t\t// iterates over all tree elements\n\t\tvar prevlen = -1;\t\t// last emitted length\n\t\tvar curlen;\t\t\t// length of current code\n\t\tvar nextlen = tree[0].dl;\t// length of next code\n\t\tvar count = 0;\t\t// repeat count of the current code\n\t\tvar max_count = 7;\t\t// max repeat count\n\t\tvar min_count = 4;\t\t// min repeat count\n\n\t\t/* tree[max_code+1].dl = -1; */  /* guard already set */\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t}\n\n\t\tfor (n = 0; n <= max_code; n++) {\n\t\t\tcurlen = nextlen;\n\t\t\tnextlen = tree[n + 1].dl;\n\t\t\tif (++count < max_count && curlen == nextlen) {\n\t\t\t\tcontinue;\n\t\t\t} else if (count < min_count) {\n\t\t\t\tdo { zip_SEND_CODE(curlen, zip_bl_tree); } while (--count != 0);\n\t\t\t} else if (curlen != 0) {\n\t\t\t\tif (curlen != prevlen) {\n\t\t\t\t\tzip_SEND_CODE(curlen, zip_bl_tree);\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\t// Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t\t\t\tzip_SEND_CODE(zip_REP_3_6, zip_bl_tree);\n\t\t\t\tzip_send_bits(count - 3, 2);\n\t\t\t} else if (count <= 10) {\n\t\t\t\tzip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);\n\t\t\t\tzip_send_bits(count - 3, 3);\n\t\t\t} else {\n\t\t\t\tzip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);\n\t\t\t\tzip_send_bits(count - 11, 7);\n\t\t\t}\n\t\t\tcount = 0;\n\t\t\tprevlen = curlen;\n\t\t\tif (nextlen == 0) {\n\t\t\t\tmax_count = 138;\n\t\t\t\tmin_count = 3;\n\t\t\t} else if (curlen == nextlen) {\n\t\t\t\tmax_count = 6;\n\t\t\t\tmin_count = 3;\n\t\t\t} else {\n\t\t\t\tmax_count = 7;\n\t\t\t\tmin_count = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Construct the Huffman tree for the bit lengths and return the index in\n\t * bl_order of the last bit length code to send.\n\t */\n\tfunction zip_build_bl_tree() {\n\t\tvar max_blindex;  // index of last bit length code of non zero freq\n\n\t\t// Determine the bit length frequencies for literal and distance trees\n\t\tzip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);\n\t\tzip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);\n\n\t\t// Build the bit length tree:\n\t\tzip_build_tree(zip_bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n\t\tfor (max_blindex = zip_BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t\t\tif (zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;\n\t\t}\n\t\t/* Update opt_len to include the bit length tree and counts */\n\t\tzip_opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t\t//    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t\t//\t    encoder->opt_len, encoder->static_len));\n\n\t\treturn max_blindex;\n\t}\n\n\t/* ==========================================================================\n\t * Send the header for a block using dynamic Huffman trees: the counts, the\n\t * lengths of the bit length codes, the literal tree and the distance tree.\n\t * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t */\n\tfunction zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n\t\tvar rank; // index in bl_order\n\n\t\t//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t\t//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n\t\t//\t    \"too many codes\");\n\t\t//    Tracev((stderr, \"\\nbl counts: \"));\n\t\tzip_send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n\t\tzip_send_bits(dcodes - 1, 5);\n\t\tzip_send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n\t\tfor (rank = 0; rank < blcodes; rank++) {\n\t\t\t//      Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t\t\tzip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);\n\t\t}\n\n\t\t// send the literal tree\n\t\tzip_send_tree(zip_dyn_ltree, lcodes - 1);\n\n\t\t// send the distance tree\n\t\tzip_send_tree(zip_dyn_dtree, dcodes - 1);\n\t}\n\n\t/* ==========================================================================\n\t * Determine the best encoding for the current block: dynamic trees, static\n\t * trees or store, and output the encoded block to the zip file.\n\t */\n\tfunction zip_flush_block(eof) { // true if this is the last block for a file\n\t\tvar opt_lenb, static_lenb; // opt_len and static_len in bytes\n\t\tvar max_blindex;\t// index of last bit length code of non zero freq\n\t\tvar stored_len;\t// length of input block\n\n\t\tstored_len = zip_strstart - zip_block_start;\n\t\tzip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items\n\n\t\t// Construct the literal and distance trees\n\t\tzip_build_tree(zip_l_desc);\n\t\t//    Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n\t\t//\t    encoder->opt_len, encoder->static_len));\n\n\t\tzip_build_tree(zip_d_desc);\n\t\t//    Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n\t\t//\t    encoder->opt_len, encoder->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n\t\tmax_blindex = zip_build_bl_tree();\n\n\t\t// Determine the best encoding. Compute first the block length in bytes\n\t\topt_lenb = (zip_opt_len + 3 + 7) >> 3;\n\t\tstatic_lenb = (zip_static_len + 3 + 7) >> 3;\n\n\t\t//    Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n\t\t//\t   opt_lenb, encoder->opt_len,\n\t\t//\t   static_lenb, encoder->static_len, stored_len,\n\t\t//\t   encoder->last_lit, encoder->last_dist));\n\n\t\tif (static_lenb <= opt_lenb)\n\t\t\topt_lenb = static_lenb;\n\t\tif (stored_len + 4 <= opt_lenb // 4: two words for the lengths\n\t\t\t&& zip_block_start >= 0) {\n\t\t\tvar i;\n\n\t\t\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t\t * the last block flush, because compression would have been\n\t\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t\t * transform a block into a stored block.\n\t\t\t */\n\t\t\tzip_send_bits((zip_STORED_BLOCK << 1) + eof, 3);  /* send block type */\n\t\t\tzip_bi_windup();\t\t /* align on byte boundary */\n\t\t\tzip_put_short(stored_len);\n\t\t\tzip_put_short(~stored_len);\n\n\t\t\t// copy block\n\t\t\t/*\n\t\t\t\t\t\tp = &window[block_start];\n\t\t\t\t\t\tfor(i = 0; i < stored_len; i++)\n\t\t\t\tput_byte(p[i]);\n\t\t\t*/\n\t\t\tfor (i = 0; i < stored_len; i++)\n\t\t\t\tzip_put_byte(zip_window[zip_block_start + i]);\n\n\t\t} else if (static_lenb == opt_lenb) {\n\t\t\tzip_send_bits((zip_STATIC_TREES << 1) + eof, 3);\n\t\t\tzip_compress_block(zip_static_ltree, zip_static_dtree);\n\t\t} else {\n\t\t\tzip_send_bits((zip_DYN_TREES << 1) + eof, 3);\n\t\t\tzip_send_all_trees(zip_l_desc.max_code + 1,\n\t\t\t\tzip_d_desc.max_code + 1,\n\t\t\t\tmax_blindex + 1);\n\t\t\tzip_compress_block(zip_dyn_ltree, zip_dyn_dtree);\n\t\t}\n\n\t\tzip_init_block();\n\n\t\tif (eof != 0)\n\t\t\tzip_bi_windup();\n\t}\n\n\t/* ==========================================================================\n\t * Save the match info and tally the frequency counts. Return true if\n\t * the current block must be flushed.\n\t */\n\tfunction zip_ct_tally(\n\t\tdist, // distance of matched string\n\t\tlc) { // match length-MIN_MATCH or unmatched char (if dist==0)\n\t\tzip_l_buf[zip_last_lit++] = lc;\n\t\tif (dist == 0) {\n\t\t\t// lc is the unmatched char\n\t\t\tzip_dyn_ltree[lc].fc++;\n\t\t} else {\n\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\tdist--;\t\t    // dist = match distance - 1\n\t\t\t//      Assert((ush)dist < (ush)MAX_DIST &&\n\t\t\t//\t     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n\t\t\t//\t     (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n\t\t\tzip_dyn_ltree[zip_length_code[lc] + zip_LITERALS + 1].fc++;\n\t\t\tzip_dyn_dtree[zip_D_CODE(dist)].fc++;\n\n\t\t\tzip_d_buf[zip_last_dist++] = dist;\n\t\t\tzip_flags |= zip_flag_bit;\n\t\t}\n\t\tzip_flag_bit <<= 1;\n\n\t\t// Output the flags if they fill a byte\n\t\tif ((zip_last_lit & 7) == 0) {\n\t\t\tzip_flag_buf[zip_last_flags++] = zip_flags;\n\t\t\tzip_flags = 0;\n\t\t\tzip_flag_bit = 1;\n\t\t}\n\t\t// Try to guess if it is profitable to stop the current block here\n\t\tif (zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {\n\t\t\t// Compute an upper bound for the compressed length\n\t\t\tvar out_length = zip_last_lit * 8;\n\t\t\tvar in_length = zip_strstart - zip_block_start;\n\t\t\tvar dcode;\n\n\t\t\tfor (dcode = 0; dcode < zip_D_CODES; dcode++) {\n\t\t\t\tout_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);\n\t\t\t}\n\t\t\tout_length >>= 3;\n\t\t\t//      Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n\t\t\t//\t     encoder->last_lit, encoder->last_dist, in_length, out_length,\n\t\t\t//\t     100L - out_length*100L/in_length));\n\t\t\tif (zip_last_dist < parseInt(zip_last_lit / 2) &&\n\t\t\t\tout_length < parseInt(in_length / 2))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn (zip_last_lit == zip_LIT_BUFSIZE - 1 ||\n\t\t\tzip_last_dist == zip_DIST_BUFSIZE);\n    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\t}\n\n  /* ==========================================================================\n   * Send the block data compressed using the given Huffman trees\n   */\n\tfunction zip_compress_block(\n\t\tltree,\t// literal tree\n\t\tdtree) {\t// distance tree\n\t\tvar dist;\t\t// distance of matched string\n\t\tvar lc;\t\t// match length or unmatched char (if dist == 0)\n\t\tvar lx = 0;\t\t// running index in l_buf\n\t\tvar dx = 0;\t\t// running index in d_buf\n\t\tvar fx = 0;\t\t// running index in flag_buf\n\t\tvar flag = 0;\t// current flags\n\t\tvar code;\t\t// the code to send\n\t\tvar extra;\t\t// number of extra bits to send\n\n\t\tif (zip_last_lit != 0) do {\n\t\t\tif ((lx & 7) == 0)\n\t\t\t\tflag = zip_flag_buf[fx++];\n\t\t\tlc = zip_l_buf[lx++] & 0xff;\n\t\t\tif ((flag & 1) == 0) {\n\t\t\t\tzip_SEND_CODE(lc, ltree); /* send a literal byte */\n\t\t\t\t//\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t\t\t} else {\n\t\t\t\t// Here, lc is the match length - MIN_MATCH\n\t\t\t\tcode = zip_length_code[lc];\n\t\t\t\tzip_SEND_CODE(code + zip_LITERALS + 1, ltree); // send the length code\n\t\t\t\textra = zip_extra_lbits[code];\n\t\t\t\tif (extra != 0) {\n\t\t\t\t\tlc -= zip_base_length[code];\n\t\t\t\t\tzip_send_bits(lc, extra); // send the extra length bits\n\t\t\t\t}\n\t\t\t\tdist = zip_d_buf[dx++];\n\t\t\t\t// Here, dist is the match distance - 1\n\t\t\t\tcode = zip_D_CODE(dist);\n\t\t\t\t//\tAssert (code < D_CODES, \"bad d_code\");\n\n\t\t\t\tzip_SEND_CODE(code, dtree);\t  // send the distance code\n\t\t\t\textra = zip_extra_dbits[code];\n\t\t\t\tif (extra != 0) {\n\t\t\t\t\tdist -= zip_base_dist[code];\n\t\t\t\t\tzip_send_bits(dist, extra);   // send the extra distance bits\n\t\t\t\t}\n\t\t\t} // literal or match pair ?\n\t\t\tflag >>= 1;\n\t\t} while (lx < zip_last_lit);\n\n\t\tzip_SEND_CODE(zip_END_BLOCK, ltree);\n\t}\n\n\t/* ==========================================================================\n\t * Send a value on a given number of bits.\n\t * IN assertion: length <= 16 and value fits in length bits.\n\t */\n\tvar zip_Buf_size = 16; // bit size of bi_buf\n\tfunction zip_send_bits(\n\t\tvalue,\t// value to send\n\t\tlength) {\t// number of bits\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n     * unused bits in value.\n     */\n\t\tif (zip_bi_valid > zip_Buf_size - length) {\n\t\t\tzip_bi_buf |= (value << zip_bi_valid);\n\t\t\tzip_put_short(zip_bi_buf);\n\t\t\tzip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));\n\t\t\tzip_bi_valid += length - zip_Buf_size;\n\t\t} else {\n\t\t\tzip_bi_buf |= value << zip_bi_valid;\n\t\t\tzip_bi_valid += length;\n\t\t}\n\t}\n\n\t/* ==========================================================================\n\t * Reverse the first len bits of a code, using straightforward code (a faster\n\t * method would use a table)\n\t * IN assertion: 1 <= len <= 15\n\t */\n\tfunction zip_bi_reverse(\n\t\tcode,\t// the value to invert\n\t\tlen) {\t// its bit length\n\t\tvar res = 0;\n\t\tdo {\n\t\t\tres |= code & 1;\n\t\t\tcode >>= 1;\n\t\t\tres <<= 1;\n\t\t} while (--len > 0);\n\t\treturn res >> 1;\n\t}\n\n\t/* ==========================================================================\n\t * Write out any remaining bits in an incomplete byte.\n\t */\n\tfunction zip_bi_windup() {\n\t\tif (zip_bi_valid > 8) {\n\t\t\tzip_put_short(zip_bi_buf);\n\t\t} else if (zip_bi_valid > 0) {\n\t\t\tzip_put_byte(zip_bi_buf);\n\t\t}\n\t\tzip_bi_buf = 0;\n\t\tzip_bi_valid = 0;\n\t}\n\n\tfunction zip_qoutbuf() {\n\t\tif (zip_outcnt != 0) {\n\t\t\tvar q, i;\n\t\t\tq = zip_new_queue();\n\t\t\tif (zip_qhead == null)\n\t\t\t\tzip_qhead = zip_qtail = q;\n\t\t\telse\n\t\t\t\tzip_qtail = zip_qtail.next = q;\n\t\t\tq.len = zip_outcnt - zip_outoff;\n\t\t\t//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);\n\t\t\tfor (i = 0; i < q.len; i++)\n\t\t\t\tq.ptr[i] = zip_outbuf[zip_outoff + i];\n\t\t\tzip_outcnt = zip_outoff = 0;\n\t\t}\n\t}\n\n\treturn function deflate(str, level) {\n\t\tvar i, j;\n\n\t\tzip_deflate_data = str;\n\t\tzip_deflate_pos = 0;\n\t\tif (typeof level == \"undefined\")\n\t\t\tlevel = zip_DEFAULT_LEVEL;\n\t\tzip_deflate_start(level);\n\n\t\tvar buff = new Array(1024);\n\t\tvar aout = [];\n\t\twhile ((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {\n\t\t\tvar cbuf = new Array(i);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tcbuf[j] = String.fromCharCode(buff[j]);\n\t\t\t}\n\t\t\taout[aout.length] = cbuf.join(\"\");\n\t\t}\n\t\tzip_deflate_data = null; // G.C.\n\t\treturn aout.join(\"\");\n\t};\n\n})();\n\n\nexport default deflate;","/* eslint-disable */\r\nimport deflate from './js-deflate/rawdeflate';\r\n//https://plantuml.com/code-javascript-synchronous\r\n\r\nconst encode64 = data => {\r\n  let r = \"\";\r\n  for (let i = 0; i < data.length; i += 3) {\r\n    if (i + 2 == data.length) {\r\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\r\n    } else if (i + 1 == data.length) {\r\n      r += append3bytes(data.charCodeAt(i), 0, 0);\r\n    } else {\r\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1),\r\n        data.charCodeAt(i + 2));\r\n    }\r\n  }\r\n  return r;\r\n};\r\n\r\nconst append3bytes = (b1, b2, b3) => {\r\n  const c1 = b1 >> 2;\r\n  const c2 = ((b1 & 0x3) << 4) | (b2 >> 4);\r\n  const c3 = ((b2 & 0xF) << 2) | (b3 >> 6);\r\n  const c4 = b3 & 0x3F;\r\n  let r = \"\";\r\n  r += encode6bit(c1 & 0x3F);\r\n  r += encode6bit(c2 & 0x3F);\r\n  r += encode6bit(c3 & 0x3F);\r\n  r += encode6bit(c4 & 0x3F);\r\n  return r;\r\n};\r\n\r\nconst encode6bit = (b) => {\r\n  if (b < 10) {\r\n    return String.fromCharCode(48 + b);\r\n  }\r\n  b -= 10;\r\n  if (b < 26) {\r\n    return String.fromCharCode(65 + b);\r\n  }\r\n  b -= 26;\r\n  if (b < 26) {\r\n    return String.fromCharCode(97 + b);\r\n  }\r\n  b -= 26;\r\n  if (b == 0) {\r\n    return '-';\r\n  }\r\n  if (b == 1) {\r\n    return '_';\r\n  }\r\n  return '?';\r\n};\r\n\r\nexport default function convertPlantUMLSourceToImageURL(pumlString) {\r\n  const unescapedUMLString = unescape(encodeURIComponent(pumlString));\r\n  const encodedString = encode64(deflate(unescapedUMLString, 9));\r\n  return \"http://www.plantuml.com/plantuml/img/\" + encodedString;\r\n}","import convertPlantUMLSourceToImageURL from '../plantuml/PlantUMLEncoder';\r\nconst defaultConfig = {\r\n\taddTitle: false\r\n}\r\nexport default function parseDiagramData(rawData, config) {\r\n\tconst { addTitle } = config ? config : defaultConfig;\r\n\r\n\tconst index = rawData.indexOf(\"@startuml\");\r\n\tif (index < 0) {\r\n\t\treturn { valid: false };\r\n\t}\r\n\tconst dataString = rawData.substring(0, index);\r\n\tlet umlString = rawData.substring(index + \"@startuml\".length);\r\n\r\n\tconst dataArray = dataString.split(\"\\n\");\r\n\tconst dataObject = {};\r\n\tdataArray.forEach(data => {\r\n\t\tdata = data.trim();\r\n\t\tif (data.startsWith(\"@\")) {\r\n\t\t\tconst spaceIndex = data.indexOf(\" \");\r\n\t\t\tif (spaceIndex < 0) {\r\n\t\t\t\tconst name = data.substring(1);\r\n\t\t\t\tdataObject[name] = true;\r\n\t\t\t} else {\r\n\t\t\t\tconst name = data.substring(1, spaceIndex).trim();\r\n\t\t\t\tconst value = data.substring(spaceIndex).trim();\r\n\t\t\t\tdataObject[name] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tif (addTitle && dataObject.title) {\r\n\t\tumlString = \"TITLE \" + dataObject.title + \"\\n\" + umlString;\r\n\t}\r\n\tconsole.log(dataObject);\r\n\tconst imageUrl = convertPlantUMLSourceToImageURL(umlString);\r\n\r\n\treturn {\r\n\t\tvalid: true,\r\n\t\tdata: dataObject,\r\n\t\tsrc: imageUrl\r\n\t};\r\n};","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport axios from 'axios';\r\nimport { CircularProgress } from '@material-ui/core';\r\nimport { ErrorOutlineOutlined } from '@material-ui/icons';\r\nimport { If, Then, Else, When } from 'react-if';\r\nimport AuthorizeDialog from '../auth/AuthorizeDialog';\r\nimport HeaderBar from '../../element/HeaderBar';\r\nimport PlantExpansionPanel from '../../element/plantuml/PlantExpansionPanel';\r\n\r\nimport { tokenStore, redirectDocIdStore } from '../../util/Store';\r\nimport parseDiagramData from '../../data/DiagramParser';\r\n\r\nexport default class DocPage extends React.Component {\r\n\tstatic propTypes = {\r\n\t\tmatch: PropTypes.any.isRequired,\r\n\t\thistory: PropTypes.any.isRequired,\r\n\t\tlocation: PropTypes.any.isRequired,\r\n\t}\r\n\tstate = {\r\n\t\tloading: true,\r\n\t\terror: false,\r\n\t\tdocument: undefined,\r\n\t};\r\n\tcomponentDidMount() {\r\n\t\tthis.updateDocument();\r\n\t}\r\n\tcomponentDidUpdate(prevProps) {\r\n\t\tif (this.props.match.params.docId !== prevProps.match.params.docId) {\r\n\t\t\tthis.updateDocument();\r\n\t\t}\r\n\r\n\t}\r\n\tupdateDocument() {\r\n\t\tconst docId = this.props.match.params.docId;\r\n\t\tif (!docId) {\r\n\t\t\tthis.props.history.push('/');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tredirectDocIdStore.store(docId);\r\n\t\tconst authorized = tokenStore.exists();\r\n\t\tif (authorized) {\r\n\t\t\tthis.loadDocument();\r\n\t\t}\r\n\t}\r\n\tloadDocument = async () => {\r\n\t\tthis.setState({\r\n\t\t\tloading: true,\r\n\t\t\terror: false,\r\n\t\t\tdocument: undefined\r\n\t\t});\r\n\t\ttry {\r\n\t\t\tconst response = await axios.get(`/docs/${this.props.match.params.docId}`, { headers: { authorization: `bearer ${tokenStore.load()}` } });\r\n\r\n\t\t\tif (response.status === 200) {\r\n\t\t\t\tconsole.log(response);\r\n\t\t\t\tconst document = {\r\n\t\t\t\t\ttitle: response.data.title,\r\n\t\t\t\t\tdocumentId: response.data.documentId,\r\n\t\t\t\t\tdiagrams: response.data.rawData.map(parseDiagramData)\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(document.diagrams);\r\n\t\t\t\tthis.setState({ document, loading: false, error: false });\r\n\t\t\t\t//this.props.changeAppTitle(response.data.title);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log(response);\r\n\t\t\t\tthis.setState({ error: true, loading: false, document: undefined });\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\tif (err.response && err.response.status === 401) {\r\n\t\t\t\ttokenStore.clear();\r\n\t\t\t}\r\n\t\t\tconsole.log(err);\r\n\t\t\tthis.setState({ error: true, loading: false, document: undefined });\r\n\t\t}\r\n\r\n\t};\r\n\trender() {\r\n\t\tconst authorized = tokenStore.exists();\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t<HeaderBar title={this.state.loading ? \"Loading Title...\" : this.state.error ? \"Error\" : this.state.document ? this.state.document.title : \"Unknown Document\"} />\r\n\t\t\t\t<AuthorizeDialog open={!authorized} onClose={() => this.props.history.push('/')} />\r\n\t\t\t\t<If condition={this.state.loading}>\r\n\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t<CircularProgress />Loading\r\n\t\t\t\t\t</Then>\r\n\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t<If condition={this.state.error}>\r\n\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t<ErrorOutlineOutlined />Error\r\n\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t<When condition={!!this.state.document}>\r\n\t\t\t\t\t\t\t\t\t{() =>\r\n\t\t\t\t\t\t\t\t\t\t<If condition={this.state.document.diagrams.filter(diagram => diagram.valid).length === 0}>\r\n\t\t\t\t\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t\t\t\t\tNo Diagram\r\n\t\t\t\t\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<div className=\"page\">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t{this.state.document.diagrams.map((diagram, i) => (\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<PlantExpansionPanel key={i} id={i} {...diagram} />\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t))}\r\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t</When>\r\n\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t</If>\r\n\t\t\t\t\t</Else>\r\n\t\t\t\t</If>\r\n\t\t\t</div>\r\n\t\t);\r\n\t};\r\n};","import React from 'react';\r\nimport HeaderBar from '../element/HeaderBar';\r\nexport default class HomePage extends React.Component {\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t<HeaderBar title=\"Home\" />\r\n\t\t\t\tHome page working in progress\r\n\t\t\t</div>\r\n\t\t);\r\n\t};\r\n};","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport axios from 'axios';\r\nimport { CircularProgress, Button, DialogActions } from '@material-ui/core';\r\nimport { DoneOutlineOutlined, ErrorOutlineOutlined } from '@material-ui/icons';\r\nimport { If, Then, Else, When } from 'react-if';\r\nimport LargeIconDialogContent from '../../element/dialog/LargeIconDialogContent';\r\nimport DialogBase from '../../element/dialog/DialogBase';\r\nimport HeaderBar from '../../element/HeaderBar';\r\nimport queryString from 'query-string';\r\nimport { tokenStore, redirectDocIdStore } from '../../util/Store';\r\n\r\nimport redirectToAuthUrl from '../../util/AuthorizeRedirector';\r\n\r\n\r\nexport default class AuthorizeFinishDialog extends React.Component {\r\n\tstatic propTypes = {\r\n\t\thistory: PropTypes.any.isRequired,\r\n\t\tmatch: PropTypes.any.isRequired,\r\n\t\tlocation: PropTypes.any.isRequired\r\n\t};\r\n\tstate = {\r\n\t\tloading: true,\r\n\t\tsuccess: false,\r\n\t\tretry: false,\r\n\t\tproceed: false,\r\n\t};\r\n\tcomponentDidMount() {\r\n\t\tif (tokenStore.exists()) {\r\n\t\t\t//Already authorized\r\n\t\t\tthis.props.history.push('/');\r\n\t\t}\r\n\t\tconst query = queryString.parse(this.props.location.search);\r\n\t\tconst code = query.code;\r\n\t\tif (!code) {\r\n\t\t\tthis.setState({\r\n\t\t\t\tloading: false,\r\n\t\t\t\tsuccess: false,\r\n\t\t\t\tproceed: false\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tif (redirectDocIdStore.exists()) {\r\n\t\t\t\tthis.setState({ proceed: true })\r\n\t\t\t}\r\n\t\t\tthis.setState({ retry: false })\r\n\t\t\tthis.verifyCode(code);\r\n\t\t}\r\n\r\n\r\n\t};\r\n\tverifyCode = async (code) => {\r\n\t\tlet success = false;\r\n\t\ttry {\r\n\t\t\tconst response = await axios.get(`/auth/token`, { params: { code } });\r\n\t\t\tif (response.status === 200) {\r\n\t\t\t\tsuccess = true;\r\n\t\t\t\ttokenStore.store(response.data.token);\r\n\t\t\t} else {\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\tconsole.log(err);\r\n\t\t}\r\n\t\tthis.setState({\r\n\t\t\tsuccess, loading: false\r\n\t\t});\r\n\t};\r\n\tretryAuthorize = () => {\r\n\t\tthis.setState({\r\n\t\t\tloading: true,\r\n\t\t\tsuccess: false,\r\n\t\t\tproceed: false,\r\n\t\t\tretry: true,\r\n\t\t}, async () => {\r\n\t\t\t//should redirect already\r\n\t\t\tawait redirectToAuthUrl();\r\n\t\t\tthis.setState({ loading: false, success: false });\r\n\t\t});\r\n\t}\r\n\tredirectHome = () => {\r\n\t\tthis.props.history.push('/');\r\n\t}\r\n\tredirectDocs = () => {\r\n\t\tif (redirectDocIdStore.exists()) {\r\n\t\t\tthis.props.history.push(`/docs/${redirectDocIdStore.load()}`);\r\n\t\t} else {\r\n\t\t\tthis.props.history.push('/');\r\n\t\t}\r\n\t}\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t<HeaderBar title=\"Authorization\" />\r\n\t\t\t\t<DialogBase open={true} onClose={() => this.redirectHome()} title=\"Authorization\">\r\n\t\t\t\t\t<If condition={this.state.loading}>\r\n\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t<If condition={this.state.retry}>\r\n\t\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t\t<LargeIconDialogContent icon={<CircularProgress size=\"5rem\" />} caption=\"Please wait...\">\r\n\t\t\t\t\t\t\t\t\t\tYou will be redirected to Google\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t\t<LargeIconDialogContent icon={<CircularProgress size=\"5rem\" />} caption=\"Just A Moment...\">\r\n\t\t\t\t\t\t\t\t\t\tWe are getting your response from Google\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t<If condition={this.state.success}>\r\n\t\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t\t<LargeIconDialogContent iconClass=\"color-safe\" icon={<DoneOutlineOutlined className=\"large-icon\" />} caption=\"Success!\">\r\n\t\t\t\t\t\t\t\t\t\tAll Done! You can start viewing your diagrams now.\r\n\t\t\t\t\t\t\t\t\t<When condition={this.state.proceed}>\r\n\t\t\t\t\t\t\t\t\t\t\t<br />Click <b>Proceed</b> to view the diagrams in your document\r\n\t\t\t\t\t\t\t\t\t</When>\r\n\t\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t\t\t<DialogActions>\r\n\t\t\t\t\t\t\t\t\t\t<If condition={this.state.proceed}>\r\n\t\t\t\t\t\t\t\t\t\t\t<Then>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<Button color=\"primary\" onClick={() => this.redirectHome()}>Back</Button>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.redirectDocs()}>Proceed</Button>\r\n\t\t\t\t\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.redirectHome()}>Done</Button>\r\n\t\t\t\t\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t\t\t\t</DialogActions>\r\n\t\t\t\t\t\t\t\t</Then>\r\n\t\t\t\t\t\t\t\t<Else>\r\n\t\t\t\t\t\t\t\t\t<LargeIconDialogContent iconClass=\" color-danger\" icon={<ErrorOutlineOutlined className=\"large-icon\" />} caption=\"Failed to authorize\">\r\n\t\t\t\t\t\t\t\t\t\tAn error occured. Click <b>Retry</b> to try again.\r\n\t\t\t\t\t\t\t\t</LargeIconDialogContent>\r\n\t\t\t\t\t\t\t\t\t<DialogActions>\r\n\t\t\t\t\t\t\t\t\t\t<Button color=\"primary\" onClick={() => this.redirectHome()}>Back</Button>\r\n\t\t\t\t\t\t\t\t\t\t<Button variant=\"contained\" color=\"primary\" onClick={() => this.retryAuthorize()}>Retry</Button>\r\n\t\t\t\t\t\t\t\t\t</DialogActions>\r\n\t\t\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t\t\t</If>\r\n\t\t\t\t\t\t</Else>\r\n\t\t\t\t\t</If>\r\n\t\t\t\t</DialogBase>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}","\r\nimport React from 'react';\r\nimport { Typography } from '@material-ui/core';\r\nexport default function Footer() {\r\n\treturn (\r\n\t\t<footer>\r\n\t\t\t<Typography variant=\"caption\" className=\"text-light\">PlantUML Doc Integration 2020</Typography>\r\n\t\t</footer>\r\n\t)\r\n}","import React from 'react';\nimport './App.css';\n\nimport { Switch, Route, withRouter } from 'react-router-dom';\n\nimport DocsPage from './page/docs/DocsPage';\nimport HomePage from './page/HomePage';\nimport AuthPage from './page/auth/AuthPage';\nimport Footer from './element/Footer';\nclass PlantDocApp extends React.Component {\n\n\trender() {\n\n\t\treturn (\n\t\t\t<div className=\"main-content\">\n\t\t\t\t<Switch>\n\t\t\t\t\t<Route path=\"/docs/:docId\" component={DocsPage} />\n\t\t\t\t\t<Route path=\"/auth\" component={AuthPage} />\n\t\t\t\t\t<Route exact path=\"/\"  >\n\t\t\t\t\t\t<HomePage />\n\t\t\t\t\t</Route>\n\t\t\t\t\t<Route path=\"*\">\n\t\t\t\t\t\tNot Found\n\t\t\t\t\t</Route>\n\n\t\t\t\t</Switch>\n\t\t\t\t<Footer />\n\t\t\t</div>\n\t\t);\n\t};\n};\nexport default withRouter(PlantDocApp);\n\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './PlantDocApp';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport * as serviceWorker from './serviceWorker';\nimport axios from 'axios';\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\naxios.defaults.baseURL = isLocalhost ? 'http://localhost:5000' : 'https://plantuml-doc-integration-api.herokuapp.com';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router><App /></Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}